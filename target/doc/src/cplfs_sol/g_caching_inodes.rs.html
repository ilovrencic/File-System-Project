<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `solution/src/g_caching_inodes.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>g_caching_inodes.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../cplfs_sol/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1"> 1</span>
<span id="2"> 2</span>
<span id="3"> 3</span>
<span id="4"> 4</span>
<span id="5"> 5</span>
<span id="6"> 6</span>
<span id="7"> 7</span>
<span id="8"> 8</span>
<span id="9"> 9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">//! File system with support for inode caching\</span>
<span class="doccomment">//! Reimplementation of the inodes from the base project.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Create a filesystem that has a notion of inodes and blocks and allows you to have a certain number of inodes in an inode cache, by implementing the [`FileSysSupport`], the [`BlockSupport`], the [`InodeSupport`] and the [`InodeRWSupport`] and [`InodeCacheSupport`] traits together (again, all earlier traits are supertraits of the last two).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! [`FileSysSupport`]: ../../cplfs_api/fs/trait.FileSysSupport.html</span>
<span class="doccomment">//! [`BlockSupport`]: ../../cplfs_api/fs/trait.BlockSupport.html</span>
<span class="doccomment">//! [`InodeSupport`]: ../../cplfs_api/fs/trait.InodeSupport.html</span>
<span class="doccomment">//! [`InodeRWSupport`]: ../../cplfs_api/fs/trait.InodeRWSupport.html</span>
<span class="doccomment">//! [`InodeCacheSupport`]: ../../cplfs_api/fs/trait.InodeCacheSupport.html</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! You have to support caching of inodes through the use of an *inode cache*, i.e. we want to make sure that:</span>
<span class="doccomment">//! - Inodes that have been read before do not have to be read from the disk again, if they are still in the cache. This is a performance improvement.</span>
<span class="doccomment">//! - If the same inode is read from the disk multiple, and multiple copies of it are in use at the same time, then each one of these copies refers to the *same* inode, and not to independent, owned instances of it, as was the case in the base project. This is a usability improvement. In other words, if one inode is read from the disk into the cache and a reference to this cache entry is kept in the code in different locations, changes to the inode in one location should be visible in all other locations, i.e. clients of our code do not have to be as careful anymore updating inodes.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Caching provides some practical issues in Rust, given that the type system does not allow us to have multiple mutable references to a single cache entry at the same time.</span>
<span class="doccomment">//! The naive solution where `i_get` returns some form of mutable reference to an inode in the cache hence does not work.</span>
<span class="doccomment">//! Essentially, the problem is that it is impossible to know statically that the cache entries will be used in a safe manner.</span>
<span class="doccomment">//! Clearly, we have to enforce ownership and borrowing at runtime.</span>
<span class="doccomment">//! One possible way of doing this consists of two parts:</span>
<span class="doccomment">//! - Use a `RefCell` to make sure that borrowing rules are only checked at runtime, i.e. use the `borrow` and `borrow_mut` methods on the `RefCell` type to perform borrow checking at runtime. `RefCell` allows for *interior mutability*, in the sense that a regular reference to a value of type `RefCell` still allows its contents to be mutated. This is safe, since `RefCell` checks the borrowing rules at runtime regardless.</span>
<span class="doccomment">//! Read more about this [here](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html).</span>
<span class="doccomment">//! - `RefCell` has some limitations; it still only allows a single party to have ownership of its values. This will not suffice if we want to keep multiple copies of a cached entry in memory. To this end, we can wrap our `RefCell`s in the `Rc` (reference count) type; this type allows us to have multiple (immutable) copies of the value it wraps. A `Rc` value keeps track of the number of owners at each point in time, and will only free its contents when the last owner goes out of scope. Read more about this [here](https://doc.rust-lang.org/book/ch15-04-rc.html). This type interacts very nicely with `RefCell`, since an immutable reference suffices to be allowed to mutate the `RefCell`&#39;s contents.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Using a combination of these two types, we can now create a shareable wrapper for our original inode type as follows:</span>
<span class="doccomment">//! ```ignore</span>
<span class="doccomment">//!use std::cell::RefCell;</span>
<span class="doccomment">//!use std::rc::Rc;</span>
<span class="doccomment">//! #[derive(Debug, Default, PartialEq, Eq, Clone)]</span>
<span class="doccomment">//! pub struct InodeCached(Rc&lt;RefCell&lt;Inode&gt;&gt;);</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! You should still implement `InodeLike` so that you can use this wrapper in your trait implementations. Additionally, think of some useful helper methods to define on this type.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! If we create a fixed-size cache data structure (pick an appropriate type for this cache in your implementation) that contains entries of this `InodeCached` type, we can actually hand out multiple copies (by cloning the `Rc` value, this implementation of `clone` is how `InodeCached` is able to derive the `Clone` trait in the above code), and make sure that they are used safely (thanks to the dynamic checking of `RefCell`).</span>
<span class="doccomment">//! This solution is still not entirely realistic, as the cache&#39;s contents will be dynamically allocated and spread across the heap when we create new `InodeCached` instances from `Inodes`, but it is already a big step in the right direction.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Now it is your turn. Implement the aforementioned cache structure, add it to your previous filesystem implementation with inodes, and make sure to implement the `InodeCacheSupport` trait.</span>
<span class="doccomment">//! Additionally, go back and fix the implementations of the functions in the `InodeSupport` to make them aware of our caching schema.</span>
<span class="doccomment">//! The following changes are required to the functions that you implemented before as part of the `InodeSupport` trait:</span>
<span class="doccomment">//! - `i_get` takes an immutable reference to `self`, and will hence be incapable of making any changes to the cache. For this reason, the `InodeCacheSupport` trait provides a new method `i_get_mut`, which takes a mutable reference to self, and hence allows updating the cache as part of the read process. More concretely `i_get` will look for an inode entry in the inode cache only, return a reference to it if it finds it and error otherwise. On the other hand, `i_get_mut` will first look in the cache and copy the behavior of `i_get`, but rather than returning an error on lookup failure, read the inode number from the disk instead. See the documentation of `i_get_mut` for more information.</span>
<span class="doccomment">//! - `i_put` still takes a reference to an inode and writes it back to the disk. The only difference is that the provided reference is now a reference to a cached inode, but this should not matter much for your implementation</span>
<span class="doccomment">//! - `i_free`: the new implementation of `i_free` differs from the old implementation (without caching) like `i_get_mut` differs from `i_get`.</span>
<span class="doccomment">//! The new implementation first tries to free the inode `i` from the cache. If the node is found, the following happens:</span>
<span class="doccomment">//!     - Returns an error if the node is still referenced elsewhere (again, you can check this through the `strong_count` method on the `Rc` type)</span>
<span class="doccomment">//!     - Does nothing and returns with an `Ok` if there are other links to this inode still (as was the case before)</span>
<span class="doccomment">//!     - Errors when trying to free an already free inode (as was the case before)</span>
<span class="doccomment">//!     - If the previous 3 cases do not occur, we can actually free the inode, as specified in `i_free`. Make sure the freed inode is written back to disk in the end.</span>
<span class="doccomment">//! If the inode is not cached, the disk inode is fetched from disk (*WARNING*: this disk inode should **NOT** end up in the cache, as we are about to free it anyways). The previous checks are then repeated, and the freed disk inode is persisted.</span>
<span class="doccomment">//! - One change to `i_alloc` is that the allocated inode will now be read into the cache too (but not returned), replacing a pre-existing free entry for the same inode if necessary.</span>
<span class="doccomment">//! We have to do this to avoid a remaining free entry in the cache for the allocated inode shadowing our allocated entry on disk. The implementation of `i_alloc` can remain otherwise unchanged, because of the following invariant of our system: *no free nodes will ever be mutated in the cache*. In other words, if `i_alloc` encounters a free inode on disk, it knows that there should not be a non-free version of this inode in the cache. This allows the implementation of `i_alloc` to disregard the cache contents.</span>
<span class="doccomment">//! - `i_trunc`, `i_read` and `i_write` do not change substantially.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! At the end, write some tests that convincingly show that your implementation indeed supports cached inodes.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Make sure this file does not contain any unaddressed `TODO`s anymore when you hand it in.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # Status</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! **TODO**: Replace the question mark below with YES, NO, or PARTIAL to</span>
<span class="doccomment">//! indicate the status of this assignment. If you want to tell something</span>
<span class="doccomment">//! about this assignment to the grader, e.g., you have a bug you can&#39;t fix,</span>
<span class="doccomment">//! or you want to explain your approach, write it down after the comments</span>
<span class="doccomment">//! section. If you had no major issues and everything works, there is no need to write any comments.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! COMPLETED: ?</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! COMMENTS:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ...</span>
<span class="doccomment">//!</span>

<span class="doccomment">/// You are free to choose the name for your file system. As we will use</span>
<span class="doccomment">/// automated tests when grading your assignment, indicate here the name of</span>
<span class="doccomment">/// your file system data type so we can just use `FSName` instead of</span>
<span class="doccomment">/// having to manually figure out the name.</span>
<span class="doccomment">/// **TODO**: replace the below type by the type of your file system</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">FSName</span> <span class="op">=</span> ();

<span class="comment">// **TODO** define your own tests here.</span>

<span class="comment">// WARNING: DO NOT TOUCH THE BELOW CODE -- IT IS REQUIRED FOR TESTING -- YOU WILL LOSE POINTS IF I MANUALLY HAVE TO FIX YOUR TESTS</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">all</span>(<span class="ident">test</span>, <span class="ident">any</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;g&quot;</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;all&quot;</span>)))]</span>
<span class="attribute">#[<span class="ident">path</span> <span class="op">=</span> <span class="string">&quot;../../api/fs-tests/g_test.rs&quot;</span>]</span>
<span class="kw">mod</span> <span class="ident">tests</span>;
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "cplfs_sol";</script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script></body></html>