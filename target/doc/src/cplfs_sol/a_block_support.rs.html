<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `solution/src/a_block_support.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>a_block_support.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../cplfs_sol/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">//! File system with block support</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Create a filesystem that only has a notion of blocks, by implementing the [`FileSysSupport`] and the [`BlockSupport`] traits together (you have no other choice, as the first one is a supertrait of the second).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! [`FileSysSupport`]: ../../cplfs_api/fs/trait.FileSysSupport.html</span>
<span class="doccomment">//! [`BlockSupport`]: ../../cplfs_api/fs/trait.BlockSupport.html</span>
<span class="doccomment">//! Make sure this file does not contain any unaddressed `TODO`s anymore when you hand it in.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # Status</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! **TODO**: Replace the question mark below with YES, NO, or PARTIAL to</span>
<span class="doccomment">//! indicate the status of this assignment. If you want to tell something</span>
<span class="doccomment">//! about this assignment to the grader, e.g., you have a bug you can&#39;t fix,</span>
<span class="doccomment">//! or you want to explain your approach, write it down after the comments</span>
<span class="doccomment">//! section. If you had no major issues and everything works, there is no need to write any comments.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! COMPLETED: YES</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! COMMENTS:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ...</span>
<span class="doccomment">//!</span>

<span class="comment">// Turn off the warnings we get from the below example imports, which are currently unused.</span>
<span class="comment">// TODO: this should be removed once you are done implementing this file. You can remove all of the below imports you do not need, as they are simply there to illustrate how you can import things.</span>
<span class="attribute">#![<span class="ident">allow</span>(<span class="ident">unused_imports</span>)]</span>
<span class="comment">// We import std::error and std::format so we can say error::Error instead of</span>
<span class="comment">// std::error::Error, etc.</span>
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fmt</span>;
<span class="kw">use</span> <span class="ident">thiserror</span>::<span class="ident">Error</span>;

<span class="comment">// If you want to import things from the API crate, do so as follows:</span>
<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">a_block_support</span>::<span class="ident">BlockFSError</span>::{
    <span class="ident">DeviceConfigurationInvalid</span>, <span class="ident">FileSystemError</span>, <span class="ident">MemoryAlreadyDeallocated</span>,
    <span class="ident">OutsideOfTheBoundariesError</span>, <span class="ident">SuperBlockInvalid</span>,
};
<span class="kw">use</span> <span class="ident">anyhow</span>::<span class="ident">private</span>::<span class="ident">new_adhoc</span>;
<span class="kw">use</span> <span class="ident">cplfs_api</span>::<span class="ident">controller</span>::<span class="ident">Device</span>;
<span class="kw">use</span> <span class="ident">cplfs_api</span>::<span class="ident">error_given</span>::<span class="ident">APIError</span>;
<span class="kw">use</span> <span class="ident">cplfs_api</span>::<span class="ident">fs</span>::{<span class="ident">BlockSupport</span>, <span class="ident">FileSysSupport</span>};
<span class="kw">use</span> <span class="ident">cplfs_api</span>::<span class="ident">types</span>::{<span class="ident">Block</span>, <span class="ident">Buffer</span>, <span class="ident">DInode</span>, <span class="ident">Inode</span>, <span class="ident">SuperBlock</span>, <span class="ident">DINODE_SIZE</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">ops</span>::{<span class="ident">Deref</span>, <span class="ident">Rem</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">panic</span>::<span class="ident">resume_unwind</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">path</span>::<span class="ident">Path</span>;

<span class="doccomment">/// You are free to choose the name for your file system. As we will use</span>
<span class="doccomment">/// automated tests when grading your assignment, indicate here the name of</span>
<span class="doccomment">/// your file system data type so we can just use `FSName` instead of</span>
<span class="doccomment">/// having to manually figure out your file system name.</span>
<span class="doccomment">/// **TODO**: replace the below type by the type of your file system</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">FSName</span> <span class="op">=</span> <span class="ident">BlockFS</span>;

<span class="doccomment">/// Main structure of the File System object</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BlockFS</span> {
    <span class="ident">device</span>: <span class="ident">Device</span>,
}
<span class="doccomment">///File System Error</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Error</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">BlockFSError</span> {
    <span class="doccomment">///Common File System error that is trigger with interaction with controller and device</span>
    <span class="attribute">#[<span class="ident">error</span>(<span class="string">&quot;File system error!&quot;</span>)]</span>
    <span class="ident">FileSystemError</span>(<span class="attribute">#[<span class="ident">from</span>]</span> <span class="ident">APIError</span>),

    <span class="doccomment">///Error that pops up when we are dealing with invalid SuperBlock segment in the File System</span>
    <span class="attribute">#[<span class="ident">error</span>(<span class="string">&quot;Superblock is not valid!&quot;</span>)]</span>
    <span class="ident">SuperBlockInvalid</span>(),

    <span class="doccomment">///Error that&#39;s triggered when the device configuration and superblock that&#39;s written on device</span>
    <span class="doccomment">/// in a mismatch.</span>
    <span class="attribute">#[<span class="ident">error</span>(<span class="string">&quot;Device configuration mismatched with superblock!&quot;</span>)]</span>
    <span class="ident">DeviceConfigurationInvalid</span>(),

    <span class="doccomment">///Error that signals that wanted action is resulting outside of the boundaries of access. E.q.</span>
    <span class="doccomment">/// when we are accessing the block that doesn&#39;t exist.</span>
    <span class="attribute">#[<span class="ident">error</span>(<span class="string">&quot;Wanted action resulted in outside of the boundaries access!&quot;</span>)]</span>
    <span class="ident">OutsideOfTheBoundariesError</span>(),

    <span class="doccomment">///Error that&#39;s triggered when we are trying to deallocated the memory that&#39;s already deallocated.</span>
    <span class="attribute">#[<span class="ident">error</span>(<span class="string">&quot;Memory, at this address, is already deallocated!&quot;</span>)]</span>
    <span class="ident">MemoryAlreadyDeallocated</span>(),
}

<span class="kw">impl</span> <span class="ident">FileSysSupport</span> <span class="kw">for</span> <span class="ident">BlockFS</span> {
    <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">BlockFSError</span>;

    <span class="kw">fn</span> <span class="ident">sb_valid</span>(<span class="ident">sb</span>: <span class="kw-2">&amp;</span><span class="ident">SuperBlock</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
        <span class="comment">//calculating number of blocks for bitmap part and inodes</span>
        <span class="kw">let</span> <span class="ident">n_super_blocks</span> <span class="op">=</span> <span class="number">1</span>;
        <span class="kw">let</span> <span class="ident">n_bitmap_blocks</span> <span class="op">=</span> (<span class="ident">sb</span>.<span class="ident">ndatablocks</span> <span class="op">/</span> (<span class="ident">sb</span>.<span class="ident">block_size</span> <span class="op">*</span> <span class="number">8</span>)) <span class="op">+</span> <span class="number">1</span>;
        <span class="kw">let</span> <span class="ident">n_of_inode_in_block</span> <span class="op">=</span> (<span class="ident">sb</span>.<span class="ident">block_size</span> <span class="op">/</span> (<span class="kw-2">*</span><span class="ident">DINODE_SIZE</span>));
        <span class="kw">let</span> <span class="ident">n_inode_blocks</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">sb</span>.<span class="ident">ninodes</span> <span class="op">%</span> <span class="ident">n_of_inode_in_block</span> <span class="op">==</span> <span class="number">0</span> {
            <span class="ident">sb</span>.<span class="ident">ninodes</span> <span class="op">/</span> <span class="ident">n_of_inode_in_block</span>
        } <span class="kw">else</span> {
            <span class="ident">sb</span>.<span class="ident">ninodes</span> <span class="op">/</span> <span class="ident">n_of_inode_in_block</span> <span class="op">+</span> <span class="number">1</span>
        };

        <span class="comment">//checking whether it is physically possible to store all the elements on the disk</span>
        <span class="kw">if</span> <span class="ident">sb</span>.<span class="ident">nblocks</span> <span class="op">&lt;</span> (<span class="ident">sb</span>.<span class="ident">ndatablocks</span> <span class="op">+</span> <span class="ident">n_inode_blocks</span> <span class="op">+</span> <span class="ident">n_bitmap_blocks</span> <span class="op">+</span> <span class="ident">n_super_blocks</span>) {
            <span class="kw">return</span> <span class="bool-val">false</span>;
        }

        <span class="comment">//checking whether there is wrong order of elements, i.e whether the elements, on the disk, are overlapping</span>
        <span class="kw">return</span> <span class="kw">if</span> <span class="op">!</span>(<span class="ident">sb</span>.<span class="ident">inodestart</span> <span class="op">&lt;</span> <span class="ident">sb</span>.<span class="ident">bmapstart</span> <span class="op">&amp;&amp;</span> <span class="ident">sb</span>.<span class="ident">bmapstart</span> <span class="op">&lt;</span> <span class="ident">sb</span>.<span class="ident">datastart</span>) {
            <span class="bool-val">false</span>
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">sb</span>.<span class="ident">inodestart</span> <span class="op">+</span> <span class="ident">n_inode_blocks</span> <span class="op">&gt;</span> <span class="ident">sb</span>.<span class="ident">bmapstart</span> {
            <span class="bool-val">false</span>
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">sb</span>.<span class="ident">bmapstart</span> <span class="op">+</span> <span class="ident">n_bitmap_blocks</span> <span class="op">&gt;</span> <span class="ident">sb</span>.<span class="ident">datastart</span> {
            <span class="bool-val">false</span>
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">sb</span>.<span class="ident">datastart</span> <span class="op">+</span> <span class="ident">sb</span>.<span class="ident">ndatablocks</span> <span class="op">&gt;</span> <span class="ident">sb</span>.<span class="ident">nblocks</span> {
            <span class="bool-val">false</span>
        } <span class="kw">else</span> {
            <span class="bool-val">true</span>
        };
    }

    <span class="kw">fn</span> <span class="ident">mkfs</span><span class="op">&lt;</span><span class="ident">P</span>: <span class="ident">AsRef</span><span class="op">&lt;</span><span class="ident">Path</span><span class="op">&gt;&gt;</span>(<span class="ident">path</span>: <span class="ident">P</span>, <span class="ident">sb</span>: <span class="kw-2">&amp;</span><span class="ident">SuperBlock</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="op">!</span><span class="ident">BlockFS</span>::<span class="ident">sb_valid</span>(<span class="ident">sb</span>) {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">SuperBlockInvalid</span>());
        }

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">device</span> <span class="op">=</span> <span class="ident">Device</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">path</span>, <span class="ident">sb</span>.<span class="ident">block_size</span>, <span class="ident">sb</span>.<span class="ident">nblocks</span>)<span class="question-mark">?</span>;

        <span class="comment">//serializing superblock into block and writing it at the position zero on the device</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">super_block</span> <span class="op">=</span> <span class="ident">Block</span>::<span class="ident">new_zero</span>(<span class="number">0</span>, <span class="ident">sb</span>.<span class="ident">block_size</span>);
        <span class="ident">super_block</span>.<span class="ident">serialize_into</span>(<span class="ident">sb</span>, <span class="number">0</span>);
        <span class="ident">device</span>.<span class="ident">write_block</span>(<span class="kw-2">&amp;</span><span class="ident">super_block</span>);

        <span class="comment">//initializing the file system with the device and returning it</span>
        <span class="kw">let</span> <span class="ident">rushfs</span> <span class="op">=</span> <span class="ident">BlockFS</span> { <span class="ident">device</span> };
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">rushfs</span>);
    }

    <span class="kw">fn</span> <span class="ident">mountfs</span>(<span class="ident">dev</span>: <span class="ident">Device</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">block_at_zero</span>: <span class="ident">Block</span> <span class="op">=</span> <span class="ident">dev</span>.<span class="ident">read_block</span>(<span class="number">0</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">superblock</span> <span class="op">=</span> <span class="ident">block_at_zero</span>.<span class="ident">deserialize_from</span>::<span class="op">&lt;</span><span class="ident">SuperBlock</span><span class="op">&gt;</span>(<span class="number">0</span>).<span class="ident">unwrap</span>();

        <span class="comment">//checking whether the superblock in the device is valid</span>
        <span class="kw">if</span> <span class="op">!</span><span class="ident">BlockFS</span>::<span class="ident">sb_valid</span>(<span class="kw-2">&amp;</span><span class="ident">superblock</span>) {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">SuperBlockInvalid</span>());
        }

        <span class="comment">//checking whether the block size in superblock and device are matching</span>
        <span class="kw">if</span> <span class="op">!</span>((<span class="ident">superblock</span>.<span class="ident">block_size</span> <span class="op">==</span> <span class="ident">dev</span>.<span class="ident">block_size</span>) <span class="op">&amp;&amp;</span> (<span class="ident">superblock</span>.<span class="ident">nblocks</span> <span class="op">==</span> <span class="ident">dev</span>.<span class="ident">nblocks</span>)) {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">DeviceConfigurationInvalid</span>());
        }

        <span class="kw">let</span> <span class="ident">rustfs</span> <span class="op">=</span> <span class="ident">BlockFS</span> { <span class="ident">device</span>: <span class="ident">dev</span> };
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">rustfs</span>);
    }

    <span class="kw">fn</span> <span class="ident">unmountfs</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Device</span> {
        <span class="kw">return</span> <span class="self">self</span>.<span class="ident">device</span>;
    }
}

<span class="kw">impl</span> <span class="ident">BlockSupport</span> <span class="kw">for</span> <span class="ident">BlockFS</span> {
    <span class="kw">fn</span> <span class="ident">b_get</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">i</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Block</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">block</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">device</span>.<span class="ident">read_block</span>(<span class="ident">i</span>);

        <span class="kw">return</span> <span class="kw">if</span> <span class="ident">block</span>.<span class="ident">is_ok</span>() {
            <span class="prelude-val">Ok</span>(<span class="ident">block</span>.<span class="ident">unwrap</span>())
        } <span class="kw">else</span> {
            <span class="prelude-val">Err</span>(<span class="ident">FileSystemError</span>(<span class="ident">block</span>.<span class="ident">unwrap_err</span>()))
        };
    }

    <span class="kw">fn</span> <span class="ident">b_put</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">b</span>: <span class="kw-2">&amp;</span><span class="ident">Block</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">device</span>.<span class="ident">write_block</span>(<span class="ident">b</span>);

        <span class="kw">if</span> <span class="ident">result</span>.<span class="ident">is_err</span>() {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">FileSystemError</span>(<span class="ident">result</span>.<span class="ident">unwrap_err</span>()));
        }

        <span class="kw">return</span> <span class="prelude-val">Ok</span>(());
    }

    <span class="kw">fn</span> <span class="ident">b_free</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">i</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">sb</span>: <span class="ident">SuperBlock</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">sup_get</span>()<span class="question-mark">?</span>;

        <span class="kw">if</span> <span class="ident">i</span> <span class="op">&gt;=</span> <span class="ident">sb</span>.<span class="ident">ndatablocks</span> {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">OutsideOfTheBoundariesError</span>());
        }

        <span class="comment">//searching for the block that contains the bit we want to change</span>
        <span class="comment">//NOTE: We assume that the first bit starts from 0 to 8*block_size bits, and then the second</span>
        <span class="comment">//block starts at 8*block_size+1 - 8*2*block_size.</span>
        <span class="kw">let</span> <span class="ident">bitmap_block_number</span> <span class="op">=</span> (<span class="ident">i</span> <span class="op">/</span> (<span class="ident">sb</span>.<span class="ident">block_size</span> <span class="op">*</span> <span class="number">8</span>));

        <span class="comment">//reading the block from the device and</span>
        <span class="comment">//getting the buffer data from the bitmap block</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">current_block</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">device</span>.<span class="ident">read_block</span>(<span class="ident">sb</span>.<span class="ident">bmapstart</span> <span class="op">+</span> <span class="ident">bitmap_block_number</span>)<span class="question-mark">?</span>;
        <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">current_block</span>.<span class="ident">contents_as_ref</span>();

        <span class="comment">//we position ourself on the index of the bitmap block we want to check.</span>
        <span class="comment">//after we position ourself, we start by finding the corresponding bit we need to free.</span>
        <span class="comment">//if we find that the bit is already free (zero), then we throw an error, otherwise</span>
        <span class="comment">// we set it to zero.</span>
        <span class="kw">let</span> <span class="ident">index</span> <span class="op">=</span> (<span class="ident">i</span> <span class="op">-</span> (<span class="ident">sb</span>.<span class="ident">block_size</span> <span class="op">*</span> <span class="number">8</span>) <span class="op">*</span> <span class="ident">bitmap_block_number</span>) <span class="op">/</span> <span class="number">8</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">changed_data</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();
        <span class="kw">for</span> <span class="ident">j</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">data</span>.<span class="ident">len</span>() {
            <span class="kw">if</span> <span class="ident">j</span> <span class="op">==</span> <span class="ident">index</span> <span class="kw">as</span> <span class="ident">usize</span> {
                <span class="kw">let</span> <span class="ident">k</span> <span class="op">=</span> (<span class="ident">i</span> <span class="op">-</span> (<span class="ident">sb</span>.<span class="ident">block_size</span> <span class="op">*</span> <span class="number">8</span>) <span class="op">*</span> <span class="ident">bitmap_block_number</span>) <span class="op">%</span> <span class="number">8</span>;

                <span class="kw">if</span> <span class="ident">data</span>[<span class="ident">j</span>] <span class="op">&amp;</span> (<span class="number">1</span> <span class="op">&lt;&lt;</span> <span class="ident">k</span>) <span class="op">&gt;</span> <span class="number">0</span> {
                    <span class="kw">let</span> <span class="ident">new_data</span>: <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>[<span class="ident">j</span>] <span class="op">^</span> (<span class="number">1</span> <span class="op">&lt;&lt;</span> <span class="ident">k</span>);
                    <span class="ident">changed_data</span>.<span class="ident">push</span>(<span class="ident">new_data</span>);
                } <span class="kw">else</span> {
                    <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">MemoryAlreadyDeallocated</span>());
                }
            } <span class="kw">else</span> {
                <span class="ident">changed_data</span>.<span class="ident">push</span>(<span class="ident">data</span>[<span class="ident">j</span>]);
            }
        }

        <span class="ident">current_block</span>.<span class="ident">write_data</span>(<span class="kw-2">&amp;</span><span class="ident">changed_data</span>, <span class="number">0</span>);
        <span class="self">self</span>.<span class="ident">device</span>.<span class="ident">write_block</span>(<span class="kw-2">&amp;</span><span class="ident">current_block</span>);

        <span class="kw">return</span> <span class="prelude-val">Ok</span>(());
    }

    <span class="kw">fn</span> <span class="ident">b_zero</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">i</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">sb</span>: <span class="ident">SuperBlock</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">sup_get</span>()<span class="question-mark">?</span>;

        <span class="kw">if</span> <span class="ident">i</span> <span class="op">&gt;=</span> <span class="ident">sb</span>.<span class="ident">ndatablocks</span> {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">OutsideOfTheBoundariesError</span>());
        }

        <span class="kw">let</span> <span class="ident">zero_data_block</span> <span class="op">=</span> <span class="ident">Block</span>::<span class="ident">new_zero</span>(<span class="ident">i</span> <span class="op">+</span> <span class="ident">sb</span>.<span class="ident">datastart</span>, <span class="ident">sb</span>.<span class="ident">block_size</span>);
        <span class="self">self</span>.<span class="ident">device</span>.<span class="ident">write_block</span>(<span class="kw-2">&amp;</span><span class="ident">zero_data_block</span>);

        <span class="kw">return</span> <span class="prelude-val">Ok</span>(());
    }

    <span class="kw">fn</span> <span class="ident">b_alloc</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u64</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">superblock</span>: <span class="ident">SuperBlock</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">sup_get</span>()<span class="question-mark">?</span>;
        <span class="kw">let</span> <span class="ident">bitmap_blocks</span> <span class="op">=</span> (<span class="ident">superblock</span>.<span class="ident">ndatablocks</span> <span class="op">/</span> (<span class="ident">superblock</span>.<span class="ident">block_size</span> <span class="op">*</span> <span class="number">8</span>));

        <span class="comment">//going through all the bitmap blocks, and then going through all the bytes of data inside those blocks.</span>
        <span class="comment">//we are looking for first bit that&#39;s zero and then we allocate that block of data.</span>
        <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">bitmap_blocks</span> <span class="op">+</span> <span class="number">1</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">current_block</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">device</span>.<span class="ident">read_block</span>(<span class="ident">superblock</span>.<span class="ident">bmapstart</span> <span class="op">+</span> <span class="ident">i</span>)<span class="question-mark">?</span>;
            <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">current_block</span>.<span class="ident">contents_as_ref</span>();

            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">changed_data</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">counter</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="number">0</span>;
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">is_data_changed</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="bool-val">false</span>;
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">index</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="number">0</span>;

            <span class="comment">//going through all the bytes of data inside the current block</span>
            <span class="kw">for</span> <span class="ident">j</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">data</span>.<span class="ident">len</span>() {
                <span class="comment">//checking whether the data was changed and whether the data is 255.</span>
                <span class="comment">//if the data hasn&#39;t been changed and data isn&#39;t 255, it means that there is some zero in the byte, and</span>
                <span class="comment">//that&#39;s the location where we are going to allocate free memory.</span>
                <span class="kw">if</span> <span class="op">!</span><span class="ident">is_data_changed</span> <span class="op">&amp;&amp;</span> <span class="ident">data</span>[<span class="ident">j</span>] <span class="op">!=</span> <span class="number">255</span> {
                    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">k</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">0</span>;
                    <span class="kw">while</span> (<span class="ident">data</span>[<span class="ident">j</span>] <span class="op">&amp;</span> (<span class="number">1</span> <span class="op">&lt;&lt;</span> <span class="ident">k</span>)) <span class="op">&gt;</span> <span class="number">0</span> {
                        <span class="ident">k</span> <span class="op">+=</span> <span class="number">1</span>;
                    }

                    <span class="kw">let</span> <span class="ident">bit_mask</span> <span class="op">=</span> <span class="ident">u8</span>::<span class="ident">pow</span>(<span class="number">2</span>, <span class="ident">k</span>);
                    <span class="kw">let</span> <span class="ident">new_value</span> <span class="op">=</span> <span class="ident">data</span>[<span class="ident">j</span>] <span class="op">|</span> <span class="ident">bit_mask</span>;
                    <span class="ident">changed_data</span>.<span class="ident">push</span>(<span class="ident">new_value</span>);
                    <span class="ident">is_data_changed</span> <span class="op">=</span> <span class="bool-val">true</span>;

                    <span class="comment">//index of the data block we just initialized</span>
                    <span class="ident">index</span> <span class="op">=</span> <span class="ident">superblock</span>.<span class="ident">datastart</span> <span class="op">+</span> <span class="ident">i</span> <span class="op">*</span> <span class="ident">superblock</span>.<span class="ident">block_size</span> <span class="op">+</span> <span class="ident">counter</span> <span class="op">+</span> (<span class="ident">k</span> <span class="kw">as</span> <span class="ident">u64</span>);

                    <span class="comment">//if the index is larger than the range for data blocks,</span>
                    <span class="comment">//that means that there is an error</span>
                    <span class="kw">if</span> <span class="ident">index</span> <span class="op">&gt;</span> <span class="ident">superblock</span>.<span class="ident">ndatablocks</span> <span class="op">+</span> <span class="ident">superblock</span>.<span class="ident">datastart</span> <span class="op">-</span> <span class="number">1</span> {
                        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">OutsideOfTheBoundariesError</span>());
                    }

                    <span class="self">self</span>.<span class="ident">b_zero</span>(<span class="ident">index</span>);
                    <span class="ident">index</span> <span class="op">=</span> <span class="ident">k</span> <span class="kw">as</span> <span class="ident">u64</span>;
                    <span class="kw">continue</span>;
                }

                <span class="comment">//if the that has been changed or the data block is equal to 255, we just pass the</span>
                <span class="comment">//unchanged data and increase the counter</span>
                <span class="ident">changed_data</span>.<span class="ident">push</span>(<span class="ident">data</span>[<span class="ident">j</span>]);
                <span class="ident">counter</span> <span class="op">+=</span> <span class="number">8</span>;
            }

            <span class="comment">//At the end we are checking whether we changed anything in the block. If we did, then we</span>
            <span class="comment">//have to write that in the block and change it on the device. After that we return the index</span>
            <span class="comment">//at which we allocated this new memory.</span>
            <span class="kw">if</span> <span class="ident">is_data_changed</span> {
                <span class="ident">current_block</span>.<span class="ident">write_data</span>(<span class="kw-2">&amp;</span><span class="ident">changed_data</span>, <span class="number">0</span>);
                <span class="self">self</span>.<span class="ident">device</span>.<span class="ident">write_block</span>(<span class="kw-2">&amp;</span><span class="ident">current_block</span>);
                <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">index</span>);
            }
        }

        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">OutsideOfTheBoundariesError</span>());
    }

    <span class="kw">fn</span> <span class="ident">sup_get</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">SuperBlock</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">block</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">device</span>.<span class="ident">read_block</span>(<span class="number">0</span>);

        <span class="kw">return</span> <span class="kw">if</span> <span class="ident">block</span>.<span class="ident">is_ok</span>() {
            <span class="kw">let</span> <span class="ident">superblock</span> <span class="op">=</span> <span class="ident">block</span>.<span class="ident">unwrap</span>().<span class="ident">deserialize_from</span>::<span class="op">&lt;</span><span class="ident">SuperBlock</span><span class="op">&gt;</span>(<span class="number">0</span>);

            <span class="kw">if</span> <span class="ident">superblock</span>.<span class="ident">is_ok</span>() {
                <span class="prelude-val">Ok</span>(<span class="ident">superblock</span>.<span class="ident">unwrap</span>())
            } <span class="kw">else</span> {
                <span class="prelude-val">Err</span>(<span class="ident">FileSystemError</span>(<span class="ident">superblock</span>.<span class="ident">unwrap_err</span>()))
            }
        } <span class="kw">else</span> {
            <span class="prelude-val">Err</span>(<span class="ident">FileSystemError</span>(<span class="ident">block</span>.<span class="ident">unwrap_err</span>()))
        };
    }

    <span class="kw">fn</span> <span class="ident">sup_put</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">sup</span>: <span class="kw-2">&amp;</span><span class="ident">SuperBlock</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">block</span>: <span class="ident">Block</span> <span class="op">=</span> <span class="ident">Block</span>::<span class="ident">new_zero</span>(<span class="number">0</span>, <span class="ident">sup</span>.<span class="ident">block_size</span>);

        <span class="ident">block</span>.<span class="ident">serialize_into</span>(<span class="kw-2">&amp;</span><span class="ident">sup</span>, <span class="number">0</span>);
        <span class="self">self</span>.<span class="ident">device</span>.<span class="ident">write_block</span>(<span class="kw-2">&amp;</span><span class="ident">block</span>);

        <span class="kw">return</span> <span class="prelude-val">Ok</span>(());
    }
}

<span class="comment">// Here we define a submodule, called `my_tests`, that will contain your unit</span>
<span class="comment">// tests for this module.</span>
<span class="comment">// **TODO** define your own tests here. I have written down one test as an example of the syntax.</span>
<span class="comment">// You can define more tests in different modules, and change the name of this module</span>
<span class="comment">//</span>
<span class="comment">// The `test` in the `#[cfg(test)]` annotation ensures that this code is only compiled when we&#39;re testing the code.</span>
<span class="comment">// To run these tests, run the command `cargo test` in the `solution` directory</span>
<span class="comment">//</span>
<span class="comment">// To learn more about testing, check the Testing chapter of the Rust</span>
<span class="comment">// Book: https://doc.rust-lang.org/book/testing.html</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">my_tests</span> {
    <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">a_block_support</span>::<span class="ident">BlockFS</span>;
    <span class="kw">use</span> <span class="ident">cplfs_api</span>::<span class="ident">fs</span>::<span class="ident">FileSysSupport</span>;
    <span class="kw">use</span> <span class="ident">cplfs_api</span>::<span class="ident">types</span>::<span class="ident">SuperBlock</span>;

    <span class="doccomment">/// Testing whether will FileSystem return false for the superblock where the file system regions</span>
    <span class="doccomment">/// are not in the right order. E.q. Inode region is staring after bitmap region.</span>
    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">bad_order_superblock_test</span>() {
        <span class="kw">let</span> <span class="ident">bad_order_superblock1</span> <span class="op">=</span> <span class="ident">SuperBlock</span> {
            <span class="ident">block_size</span>: <span class="number">1000</span>,
            <span class="ident">nblocks</span>: <span class="number">100</span>,
            <span class="ident">ninodes</span>: <span class="number">10</span>,
            <span class="ident">inodestart</span>: <span class="number">10</span>,
            <span class="ident">ndatablocks</span>: <span class="number">5</span>,
            <span class="ident">bmapstart</span>: <span class="number">1</span>,
            <span class="ident">datastart</span>: <span class="number">5</span>,
        };

        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">BlockFS</span>::<span class="ident">sb_valid</span>(<span class="kw-2">&amp;</span><span class="ident">bad_order_superblock1</span>), <span class="bool-val">false</span>);

        <span class="kw">let</span> <span class="ident">bad_order_superblock2</span> <span class="op">=</span> <span class="ident">SuperBlock</span> {
            <span class="ident">block_size</span>: <span class="number">1000</span>,
            <span class="ident">nblocks</span>: <span class="number">100</span>,
            <span class="ident">ninodes</span>: <span class="number">10</span>,
            <span class="ident">inodestart</span>: <span class="number">1</span>,
            <span class="ident">ndatablocks</span>: <span class="number">5</span>,
            <span class="ident">bmapstart</span>: <span class="number">10</span>,
            <span class="ident">datastart</span>: <span class="number">7</span>,
        };

        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">BlockFS</span>::<span class="ident">sb_valid</span>(<span class="kw-2">&amp;</span><span class="ident">bad_order_superblock2</span>), <span class="bool-val">false</span>);

        <span class="kw">let</span> <span class="ident">bad_order_superblock3</span> <span class="op">=</span> <span class="ident">SuperBlock</span> {
            <span class="ident">block_size</span>: <span class="number">1000</span>,
            <span class="ident">nblocks</span>: <span class="number">100</span>,
            <span class="ident">ninodes</span>: <span class="number">10</span>,
            <span class="ident">inodestart</span>: <span class="number">5</span>,
            <span class="ident">ndatablocks</span>: <span class="number">5</span>,
            <span class="ident">bmapstart</span>: <span class="number">10</span>,
            <span class="ident">datastart</span>: <span class="number">1</span>,
        };

        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">BlockFS</span>::<span class="ident">sb_valid</span>(<span class="kw-2">&amp;</span><span class="ident">bad_order_superblock3</span>), <span class="bool-val">false</span>);
    }

    <span class="doccomment">/// Testing FileSystem when superblock regions are overlapping over each other.</span>
    <span class="doccomment">/// E.g. Inode region starts at 1, and bitmap region starts at 5. However, the inode region has a block size</span>
    <span class="doccomment">/// of 6, which means that it will overlap with bitmap region.</span>
    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">bad_region_size_superblock_test</span>() {
        <span class="kw">let</span> <span class="ident">bad_region_size_superblock1</span> <span class="op">=</span> <span class="ident">SuperBlock</span> {
            <span class="ident">block_size</span>: <span class="number">1000</span>,
            <span class="ident">nblocks</span>: <span class="number">100</span>,
            <span class="ident">ninodes</span>: <span class="number">10</span>,
            <span class="ident">inodestart</span>: <span class="number">1</span>,
            <span class="ident">ndatablocks</span>: <span class="number">20</span>,
            <span class="ident">bmapstart</span>: <span class="number">2</span>,
            <span class="ident">datastart</span>: <span class="number">10</span>,
        };

        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">BlockFS</span>::<span class="ident">sb_valid</span>(<span class="kw-2">&amp;</span><span class="ident">bad_region_size_superblock1</span>), <span class="bool-val">false</span>);
    }

    <span class="doccomment">/// Testing couple of examples of good superblock definitions.</span>
    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">good_superblock_test</span>() {
        <span class="kw">let</span> <span class="ident">good_superblock1</span> <span class="op">=</span> <span class="ident">SuperBlock</span> {
            <span class="ident">block_size</span>: <span class="number">1000</span>,
            <span class="ident">nblocks</span>: <span class="number">100</span>,
            <span class="ident">ninodes</span>: <span class="number">10</span>,
            <span class="ident">inodestart</span>: <span class="number">1</span>,
            <span class="ident">ndatablocks</span>: <span class="number">20</span>,
            <span class="ident">bmapstart</span>: <span class="number">6</span>,
            <span class="ident">datastart</span>: <span class="number">7</span>,
        };

        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">BlockFS</span>::<span class="ident">sb_valid</span>(<span class="kw-2">&amp;</span><span class="ident">good_superblock1</span>), <span class="bool-val">true</span>);

        <span class="kw">let</span> <span class="ident">good_superblock2</span> <span class="op">=</span> <span class="ident">SuperBlock</span> {
            <span class="ident">block_size</span>: <span class="number">1000</span>,
            <span class="ident">nblocks</span>: <span class="number">10</span>,
            <span class="ident">ninodes</span>: <span class="number">6</span>,
            <span class="ident">inodestart</span>: <span class="number">1</span>,
            <span class="ident">ndatablocks</span>: <span class="number">5</span>,
            <span class="ident">bmapstart</span>: <span class="number">4</span>,
            <span class="ident">datastart</span>: <span class="number">5</span>,
        };

        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">BlockFS</span>::<span class="ident">sb_valid</span>(<span class="kw-2">&amp;</span><span class="ident">good_superblock2</span>), <span class="bool-val">true</span>);
    }
}

<span class="comment">// If you want to write more complicated tests that create actual files on your system, take a look at `utils.rs` in the assignment, and how it is used in the `fs_tests` folder to perform the tests. I have imported it below to show you how it can be used.</span>
<span class="comment">// The `utils` folder has a few other useful methods too (nothing too crazy though, you might want to write your own utility functions, or use a testing framework in rust, if you want more advanced features)</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="attribute">#[<span class="ident">path</span> <span class="op">=</span> <span class="string">&quot;../../api/fs-tests&quot;</span>]</span>
<span class="kw">mod</span> <span class="ident">test_with_utils</span> {

    <span class="attribute">#[<span class="ident">path</span> <span class="op">=</span> <span class="string">&quot;utils.rs&quot;</span>]</span>
    <span class="kw">mod</span> <span class="ident">utils</span>;

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">unit_test</span>() {
        <span class="comment">//The below method set up the parent folder &quot;a_parent_unique_name&quot; within the root directory  of this solution crate</span>
        <span class="comment">//Also delete the file &quot;image_file&quot; within this folder if it already exists, so that it does not interfere with any later `mkfs` calls (this is useful if your previous test run failed, and the file did not get deleted)</span>
        <span class="comment">//*WARNING* !Make sure that this folder name &quot;a_parent_unique_name&quot; is actually unique over different tests, because tests are executed in parallel by default!</span>
        <span class="comment">//Returns the concatenated path, so that you can use the path further on, e.g. when creating a `Device` or `FileSystem`</span>

        <span class="doccomment">//! `let path = utils::disk_prep_path(&quot;a_parent_unique_name&quot;, &quot;image_file&quot;);`</span>

        <span class="comment">//Things you want to test go here (check my tests in the API folder for examples)</span>
        <span class="doccomment">//! ...</span>
        <span class="doccomment">//! ...</span>

        <span class="comment">// If some disk actually created the file under `path` in your code, then you can uncomment the following call to clean it up:</span>
        <span class="doccomment">//!  `utils::disk_unprep_path(&amp;path);`</span>
        <span class="comment">// This removes the image file and the parent directory at the end, so that no garbage is left in your file system</span>
        <span class="comment">//*WARNING* if a Device `dev` is still in scope for the path `path`, then the above call will block (the device holds a lock on the memory-mapped file)</span>
        <span class="comment">//You then have to use the following call instead:</span>

        <span class="doccomment">//! `utils::disk_destruct(dev);`</span>

        <span class="comment">//This makes the device go out of scope first, before tearing down the parent folder and image file, thereby avoiding deadlock</span>
    }
}

<span class="comment">// Here we define a submodule, called `tests`, that will contain our unit tests</span>
<span class="comment">// Take a look at the specified path to figure out which tests your code has to pass.</span>
<span class="comment">// As with all other files in the assignment, the testing module for this file is stored in the API crate (this is the reason for the &#39;path&#39; attribute in the code below)</span>
<span class="comment">// The reason I set it up like this is that it allows me to easily add additional tests when grading your projects, without changing any of your files, but you can still run my tests together with yours by specifying the right features (see below) :)</span>
<span class="comment">// directory.</span>
<span class="comment">//</span>
<span class="comment">// To run these tests, run the command `cargo test --features=&quot;X&quot;` in the `solution` directory, with &quot;X&quot; a space-separated string of the features you are interested in testing.</span>
<span class="comment">//</span>
<span class="comment">// WARNING: DO NOT TOUCH THE BELOW CODE -- IT IS REQUIRED FOR TESTING -- YOU WILL LOSE POINTS IF I MANUALLY HAVE TO FIX YOUR TESTS</span>
<span class="comment">//The below configuration tag specifies the following things:</span>
<span class="comment">// &#39;cfg&#39; ensures this module is only included in the source if all conditions are met</span>
<span class="comment">// &#39;all&#39; is true iff ALL conditions in the tuple hold</span>
<span class="comment">// &#39;test&#39; is only true when running &#39;cargo test&#39;, not &#39;cargo build&#39;</span>
<span class="comment">// &#39;any&#39; is true iff SOME condition in the tuple holds</span>
<span class="comment">// &#39;feature = X&#39; ensures that the code is only compiled when the cargo command includes the flag &#39;--features &quot;&lt;some-features&gt;&quot;&#39; and some features includes X.</span>
<span class="comment">// I declared the necessary features in Cargo.toml</span>
<span class="comment">// (Hint: this hacking using features is not idiomatic behavior, but it allows you to run your own tests without getting errors on mine, for parts that have not been implemented yet)</span>
<span class="comment">// The reason for this setup is that you can opt-in to tests, rather than getting errors at compilation time if you have not implemented something.</span>
<span class="comment">// The &quot;a&quot; feature will run these tests specifically, and the &quot;all&quot; feature will run all tests.</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">all</span>(<span class="ident">test</span>, <span class="ident">any</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;a&quot;</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;all&quot;</span>)))]</span>
<span class="attribute">#[<span class="ident">path</span> <span class="op">=</span> <span class="string">&quot;../../api/fs-tests/a_test.rs&quot;</span>]</span>
<span class="kw">mod</span> <span class="ident">tests</span>;
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "cplfs_sol";</script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script></body></html>