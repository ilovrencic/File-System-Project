<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `api/src/types.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>types.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../cplfs_api/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">//! Module containing the types used in this project.</span>
<span class="doccomment">//! You can define your own wrappers around these types if you need more than the provided functionality.</span>

<span class="kw">use</span> <span class="kw">super</span>::<span class="ident">error_given</span>;
<span class="kw">use</span> <span class="kw">super</span>::<span class="ident">error_given</span>::<span class="ident">APIError</span>;
<span class="kw">use</span> <span class="ident">lazy_static</span>::<span class="ident">lazy_static</span>;
<span class="kw">use</span> <span class="ident">serde</span>::{<span class="ident">de</span>::<span class="ident">DeserializeOwned</span>, <span class="ident">Deserialize</span>, <span class="ident">Serialize</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::{<span class="ident">Cursor</span>, <span class="ident">SeekFrom</span>};

<span class="doccomment">/// Buffer abstraction, representing some data on the heap.</span>
<span class="doccomment">/// Buffers can have any size, and will be used further on to build file system `Block`s with, but also as output to read and write functions on files</span>
<span class="doccomment">/// Support regular read and write methods, but also (de)serialization of structures implementing the appropriate traits</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Buffer</span> {
    <span class="doccomment">///Contents of the buffer, represented as a boxed slice</span>
    <span class="doccomment">/// The reason for this choice of data structure is that we will not have to change the size of buffers while using them.</span>
    <span class="ident">contents</span>: <span class="ident">Box</span><span class="op">&lt;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span>,
}

<span class="kw">impl</span> <span class="ident">Buffer</span> {
    <span class="doccomment">/// Create a new buffer, having the given `data` slice as its data</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">data</span>: <span class="ident">Box</span><span class="op">&lt;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Buffer</span> {
        <span class="ident">Buffer</span> { <span class="ident">contents</span>: <span class="ident">data</span> }
    }

    <span class="doccomment">/// Create an all-zero buffer, with contents length of `len`</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new_zero</span>(<span class="ident">len</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">Buffer</span> {
        <span class="ident">Buffer</span> {
            <span class="ident">contents</span>: <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="ident">len</span> <span class="kw">as</span> <span class="ident">usize</span>].<span class="ident">into_boxed_slice</span>(),
        }
    }

    <span class="doccomment">/// Size of the underlying block data</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">len</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">u64</span> {
        <span class="self">self</span>.<span class="ident">contents</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span>
    }

    <span class="doccomment">/// Return a reference to this block&#39;s contents</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">contents_as_ref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] {
        <span class="kw">return</span> <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">contents</span>;
    }

    <span class="doccomment">/// Reads data from the given buffer into the `data` buffer, starting at the given `offset`.</span>
    <span class="doccomment">/// Returns the number of bytes that were read, or an error in case of failure.</span>
    <span class="doccomment">/// If the function does not return an error, the number of bytes read should always be equal to `data.len()`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">read_data</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>], <span class="ident">offset</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">error_given</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="ident">offset</span> <span class="op">+</span> <span class="ident">data</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span> <span class="op">&gt;</span> <span class="self">self</span>.<span class="ident">len</span>() {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">APIError</span>::<span class="ident">BlockInput</span>(
                <span class="string">&quot;Trying to read beyond the bounds of the block&quot;</span>,
            ));
        }

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">Cursor</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">contents</span>);
        <span class="ident">c</span>.<span class="ident">seek</span>(<span class="ident">SeekFrom</span>::<span class="ident">Start</span>(<span class="ident">offset</span>))<span class="question-mark">?</span>;
        <span class="ident">c</span>.<span class="ident">read_exact</span>(<span class="ident">data</span>).<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span>.<span class="ident">into</span>())
    }

    <span class="doccomment">/// Writes data from the given slice into the `data.</span>
    <span class="doccomment">/// If the function does not return an error, the number of bytes written should always be equal to `data.len()`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">write_data</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">offset</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">error_given</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="ident">offset</span> <span class="op">+</span> <span class="ident">data</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span> <span class="op">&gt;</span> <span class="self">self</span>.<span class="ident">len</span>() {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">APIError</span>::<span class="ident">BlockInput</span>(
                <span class="string">&quot;Trying to write beyond the bounds of the block&quot;</span>,
            ));
        }

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">Cursor</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>.<span class="ident">contents</span>[..]);
        <span class="ident">c</span>.<span class="ident">seek</span>(<span class="ident">SeekFrom</span>::<span class="ident">Start</span>(<span class="ident">offset</span>))<span class="question-mark">?</span>;
        <span class="ident">c</span>.<span class="ident">write_all</span>(<span class="ident">data</span>).<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span>.<span class="ident">into</span>())
    }

    <span class="doccomment">/// Read any object that implements the DeserializeOwned trait from this buffer</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *EXTRA*: Note that since this method takes ownership of the deserialized data, the link with the original data in the block necessarily breaks.</span>
    <span class="doccomment">/// This is not what you would have in a high-performance C implementation, as you would simply perform a cast of the part of memory you are interested in to a struct, without having to worry about lifetimes.</span>
    <span class="doccomment">/// To keep things simple and not have additional lifetime dependencies and unsafe code here, this method was not implemented as such.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">deserialize_from</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">offset</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">error_given</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>
    <span class="kw">where</span>
        <span class="ident">S</span>: <span class="ident">DeserializeOwned</span>,
    {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">Cursor</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">contents</span>);
        <span class="ident">c</span>.<span class="ident">seek</span>(<span class="ident">SeekFrom</span>::<span class="ident">Start</span>(<span class="ident">offset</span>))<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>((<span class="ident">bincode</span>::<span class="ident">deserialize_from</span>(<span class="ident">c</span>))<span class="question-mark">?</span>)
    }

    <span class="doccomment">/// Write any object that implements the Serialize trait into this buffer</span>
    <span class="doccomment">/// Goes through `write_data` so that the appropriate error get triggered.</span>
    <span class="doccomment">/// Alternatively, we could go through `serialize_into` [`bincode`](https://docs.rs/bincode/1.3.1/bincode/index.html) and use the standard error.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">serialize_into</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">stru</span>: <span class="kw-2">&amp;</span><span class="ident">S</span>, <span class="ident">offset</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">error_given</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span>
    <span class="kw">where</span>
        <span class="ident">S</span>: <span class="ident">Serialize</span>,
    {
        <span class="kw">let</span> <span class="ident">stru_bin</span> <span class="op">=</span> <span class="ident">bincode</span>::<span class="ident">serialize</span>(<span class="ident">stru</span>)<span class="question-mark">?</span>;
        <span class="comment">//Going through write data so that the appropriate errors get triggered</span>
        <span class="self">self</span>.<span class="ident">write_data</span>(<span class="kw-2">&amp;</span><span class="ident">stru_bin</span>, <span class="ident">offset</span>)
    }
}

<span class="doccomment">/// Block abstraction, representing a block of data read from the disk.</span>
<span class="doccomment">/// Provides basic methods to read and write data and select structures from and to a block.</span>
<span class="doccomment">/// The basic unit read and written by the device controller, that our file system will make use of.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// *EXTRA*: Note that in a real life setting, the device controller would often simply read and write blocks from/to a memory-mapped region (this is a form of so-called DMA, Direct Memory Access).</span>
<span class="doccomment">/// This `Block` abstraction would hence not exist at the level of the controller.</span>
<span class="doccomment">/// We nevertheless lowered the abstraction of blocks to the level of the device controller, as it sending around raw `Vec`s or arrays is not much more realistic anyway.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Block</span> {
    <span class="doccomment">///Index of this block sector on the disk</span>
    <span class="kw">pub</span> <span class="ident">block_no</span>: <span class="ident">u64</span>,
    <span class="doccomment">///Contents of the block, represented as a `Buffer`. The block will relay all of its method implementations to this buffer contents.</span>
    <span class="doccomment">/// The reason for this choice of data structure is that we will not have to change the size of memory blocks while using them.</span>
    <span class="ident">buf</span>: <span class="ident">Buffer</span>,
}

<span class="kw">impl</span> <span class="ident">Block</span> {
    <span class="doccomment">/// Create a new block, corresponding to block `block_no` on disk, having the given `data` slice as its data</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">block_no</span>: <span class="ident">u64</span>, <span class="ident">data</span>: <span class="ident">Box</span><span class="op">&lt;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="ident">Block</span> {
        <span class="ident">Block</span> {
            <span class="ident">block_no</span>: <span class="ident">block_no</span>,
            <span class="ident">buf</span>: <span class="ident">Buffer</span>::<span class="ident">new</span>(<span class="ident">data</span>),
        }
    }

    <span class="doccomment">/// Create an all-zero block, with contents length of `len`</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new_zero</span>(<span class="ident">block_no</span>: <span class="ident">u64</span>, <span class="ident">len</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">Block</span> {
        <span class="ident">Block</span> {
            <span class="ident">block_no</span>: <span class="ident">block_no</span>,
            <span class="ident">buf</span>: <span class="ident">Buffer</span>::<span class="ident">new_zero</span>(<span class="ident">len</span>),
        }
    }
    <span class="doccomment">/// Size of the underlying block data</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">len</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">u64</span> {
        <span class="self">self</span>.<span class="ident">buf</span>.<span class="ident">contents</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span>
    }

    <span class="doccomment">/// Return a reference to this block&#39;s contents</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">contents_as_ref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] {
        <span class="kw">return</span> <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">buf</span>.<span class="ident">contents_as_ref</span>();
    }

    <span class="doccomment">/// Reads data from the given block into the `data` buffer, starting at the given `offset`.</span>
    <span class="doccomment">/// Returns the number of bytes that were read, or an error in case of failure.</span>
    <span class="doccomment">/// If the function does not return an error, the number of bytes read should always be equal to `data.len()`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">read_data</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>], <span class="ident">offset</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">error_given</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">buf</span>.<span class="ident">read_data</span>(<span class="ident">data</span>, <span class="ident">offset</span>)
    }

    <span class="doccomment">/// Writes data from the given slice into the `data.</span>
    <span class="doccomment">/// If the function does not return an error, the number of bytes written should always be equal to `data.len()`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">write_data</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">offset</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">error_given</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">buf</span>.<span class="ident">write_data</span>(<span class="ident">data</span>, <span class="ident">offset</span>)
    }

    <span class="doccomment">/// Read any object that implements the DeserializeOwned trait from this block</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *EXTRA*: Note that since this method takes ownership of the deserialized data, the link with the original data in the block necessarily breaks.</span>
    <span class="doccomment">/// This is not what you would have in a high-performance C implementation, as you would simply perform a cast of the part of memory you are interested in to a struct, without having to worry about lifetimes.</span>
    <span class="doccomment">/// To keep things simple and not have additional lifetime dependencies here, this method was not implemented as such.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">deserialize_from</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">offset</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">error_given</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>
    <span class="kw">where</span>
        <span class="ident">S</span>: <span class="ident">DeserializeOwned</span>,
    {
        <span class="self">self</span>.<span class="ident">buf</span>.<span class="ident">deserialize_from</span>(<span class="ident">offset</span>)
    }

    <span class="doccomment">/// Write any object that implements the Serialize trait into this block</span>
    <span class="doccomment">/// Goes through `write_data` so that the appropriate errors get triggered, because using `serialize_into` from [`bincode`](https://docs.rs/bincode/1.3.1/bincode/index.html) would risk extending the underlying vector instead of throwing an error.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">serialize_into</span><span class="op">&lt;</span><span class="ident">S</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">stru</span>: <span class="kw-2">&amp;</span><span class="ident">S</span>, <span class="ident">offset</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">error_given</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span>
    <span class="kw">where</span>
        <span class="ident">S</span>: <span class="ident">Serialize</span>,
    {
        <span class="self">self</span>.<span class="ident">buf</span>.<span class="ident">serialize_into</span>(<span class="ident">stru</span>, <span class="ident">offset</span>)
    }
}

<span class="doccomment">/// Structure representing all file system metadata that we are interested in, and hence the file system&#39;s structure.</span>
<span class="doccomment">/// Note that the size of the Superblock struct does not necessarily have to be a full block, as it can just be read from disk contiguously.</span>
<span class="doccomment">/// Rather, the size of `SuperBlock` must be at most as large as a single disk block.</span>
<span class="doccomment">/// Derives `Serialize` and `Deserialize` so we can easily write this block to the disk and read it again after.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The layout of the simple file system model we use is as follows:</span>
<span class="doccomment">///     \[super block | inode blocks | free bit map | data blocks\]</span>
<span class="doccomment">/// , where each component has the following meaning:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// 1. *super block*: aggregates all the file system meta-data including the sizes of all subsequent regions. This is the first block that is read by the file system driver when loading an existing file system, and the first block to be written by the driver in case a new file system is initialized. This area should consist of a single block, i.e. the `SuperBlock` type defined below should not take up more space in memory than a single block, defined by `Disk.block_size` in [`controller.rs`](../controller/index.html).</span>
<span class="doccomment">/// 2. *inode blocks*: a sequence of blocks containing all the inode metadata. This region contains all inodes in order, starting from inode 1 (the root directory, i.e. the directory on your computer with path &quot;\&quot;), all the way up to the last inode. The number of inodes stored in each block is equal to the floor of the block size divided by the inode size, i.e. blocks are packed with inodes, and individual inodes are always entirely stored in a single block (they are never broken up over multiple blocks).</span>
<span class="doccomment">/// 3. *free bit map*: a sequence of blocks keeping track of the allocation state (allocated or free) of all disk blocks in the next data block region. The *n*th bit in this sequence specifies whether or not the *n*th data block is currently in use.</span>
<span class="doccomment">/// 4. *data blocks*: contain the actual file and directory data, as a long sequence of disk blocks.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// *EXTRA*: Since we do not support logging, there is no need for an additional memory region to store any logs in</span>
<span class="doccomment">/// Also note that in contrast to more realistic device layouts, we ignore the fact that the first block of the device is often reserved for bootstrapping code, and makes use of e.g. a Master Boot Record (MBR) or Volume Boot Record (VBR).</span>
<span class="doccomment">/// *EXTRA*: Note that just like blocks, inodes are not being cached either. The consequence is that the users of our APIs are responsible for ensuring that they aren&#39;t handling different aliases to the same inode without realizing it. This will not scale well to a parallellized setting. In our case, this is no major problem, as we have no parallellism, and we have simple system call interactions, that will not handle a lot of inodes at the same time, and will hence not need to perform many of those inode equality checks.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SuperBlock</span> {
    <span class="doccomment">///Size of the blocks in the current file system, in *BYTES*\</span>
    <span class="doccomment">///In a real world application, this block size does not necessarily match the size of the sectors on the device itself, but for simplicity reasons we assume this value and the disk sector size in `Device.block_size` to always be equal</span>
    <span class="kw">pub</span> <span class="ident">block_size</span>: <span class="ident">u64</span>,
    <span class="doccomment">///Number of blocks in the entire file system, including this block and the 3 other file system regions\</span>
    <span class="doccomment">///This number does not necessarily have to equal the size of the disk this file system is stored on, as long as the file system fits on the disk</span>
    <span class="kw">pub</span> <span class="ident">nblocks</span>: <span class="ident">u64</span>,
    <span class="doccomment">///Number of inodes that we keep track of in the inode region\</span>
    <span class="doccomment">///This number does not necessarily have to fill up the entire region, i.e. it is possible to make the inode region unnecessarily big</span>
    <span class="kw">pub</span> <span class="ident">ninodes</span>: <span class="ident">u64</span>,
    <span class="doccomment">///The block index of the first block of inodes\</span>
    <span class="doccomment">///Since the super block is only a single block long and located at index 0, this will usually be the block with index\</span>
    <span class="doccomment">///The inode region runs until `bmapstart`\</span>
    <span class="doccomment">///The inode region is assumed to be sufficiently long to contain `niondes` inodes</span>
    <span class="kw">pub</span> <span class="ident">inodestart</span>: <span class="ident">u64</span>,
    <span class="doccomment">///Number of data blocks that we keep track of in the bitmap region\</span>
    <span class="doccomment">///This number does not necessarily have to fill up the entire bitmap or data region, i.e. it is possible to make the bitmap and/or block data region unnecessarily big</span>
    <span class="kw">pub</span> <span class="ident">ndatablocks</span>: <span class="ident">u64</span>,
    <span class="doccomment">///The block index of the first block of the free bit map region\</span>
    <span class="doccomment">///The free bit map region runs until `datastart`\</span>
    <span class="doccomment">///The free bit map region is assumed to be at least `ndatablocks` bits large\</span>
    <span class="kw">pub</span> <span class="ident">bmapstart</span>: <span class="ident">u64</span>,
    <span class="doccomment">///The block index of the first block of the data blocks region\</span>
    <span class="doccomment">///The data block region runs until `nblocks`, i.e. the end of the file system\</span>
    <span class="doccomment">///The data block region is assumed to be at least `ndatablocks` blocks large</span>
    <span class="kw">pub</span> <span class="ident">datastart</span>: <span class="ident">u64</span>,
}

<span class="macro">lazy_static</span><span class="macro">!</span> {
    <span class="doccomment">/// Size the superblock takes up in memory on your system, in bytes.</span>
    <span class="doccomment">/// This size can only be found out at runtime, which is the reason why we have to wrap this code in a `lazy_static` macro.</span>
    <span class="doccomment">/// Notice the use of the `ref` keyword; `SUPERBLOCK_SIZE` is a reference to an `u64` number, that will only be filled in at runtime.</span>
    <span class="doccomment">/// Used to determine the number of inodes per block, which is important for filesystem initialization.</span>
    <span class="kw">pub</span> <span class="kw">static</span> <span class="kw-2">ref</span> <span class="ident">SUPERBLOCK_SIZE</span> : <span class="ident">u64</span> <span class="op">=</span> <span class="ident">bincode</span>::<span class="ident">serialize</span>(<span class="kw-2">&amp;</span><span class="ident">SuperBlock</span>::<span class="ident">default</span>()).<span class="ident">unwrap</span>().<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span>;
}

<span class="doccomment">/// Hard-coded number of data blocks each inode can point to</span>
<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">DIRECT_POINTERS</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="number">12</span>;

<span class="doccomment">/// Enum describing file types</span>
<span class="doccomment">/// Currently, either a file `T_FILE`, a directory `T_DIR` or a free inode `T_Free`</span>
<span class="doccomment">/// The file type `T_FREE` is used to signify a free inode, that can be used to allocate a new file or directory.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">Copy</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">FType</span> {
    <span class="doccomment">/// Directory file type</span>
    <span class="ident">TDir</span>,
    <span class="doccomment">/// Regular file type</span>
    <span class="ident">TFile</span>,
    <span class="doccomment">/// Free file type</span>
    <span class="ident">TFree</span>,
}
<span class="kw">impl</span> <span class="ident">Default</span> <span class="kw">for</span> <span class="ident">FType</span> {
    <span class="kw">fn</span> <span class="ident">default</span>() <span class="op">-&gt;</span> <span class="ident">FType</span> {
        <span class="ident">FType</span>::<span class="ident">TFree</span>
    }
}

<span class="doccomment">/// Struct describing data held by an inode on the disk.</span>
<span class="doccomment">/// Derives the Serialize and Deserialize traits, to allow for easy (de-)serialization when writing to disk blocks</span>
<span class="doccomment">///</span>
<span class="doccomment">/// *EXTRA*: In real-life file systems, files also contain a field pointing to a data block containing more data blocks, called an indirect pointer.</span>
<span class="doccomment">/// For simplicity reasons, we do not support this in the current file system.</span>
<span class="doccomment">/// In other words, files are made up of a total of at most `DIRECT_POINTERS` blocks.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DInode</span> {
    <span class="doccomment">/// Registers the file type</span>
    <span class="kw">pub</span> <span class="ident">ft</span>: <span class="ident">FType</span>,
    <span class="doccomment">/// Counts the number of links to this inode in the file system. The point of doing this is that if the inode is written back to disk when it has no links to it, it should be freed instead, thereby setting its file type to `T_FREE`.</span>
    <span class="kw">pub</span> <span class="ident">nlink</span>: <span class="ident">u16</span>,
    <span class="doccomment">/// Size of the file in bytes. Used to see when a read or write would go out of file bounds.</span>
    <span class="kw">pub</span> <span class="ident">size</span>: <span class="ident">u64</span>,
    <span class="doccomment">/// A list of up to `DIRECT_POINTERS` valid block addresses (counting from 0, *not* from the start of the data block region), to specify where the contents of this file are stored.</span>
    <span class="kw">pub</span> <span class="ident">direct_blocks</span>: [<span class="ident">u64</span>; <span class="ident">DIRECT_POINTERS</span> <span class="kw">as</span> <span class="ident">usize</span>],
}

<span class="macro">lazy_static</span><span class="macro">!</span> {
    <span class="doccomment">/// Size of an inode in your system, in bytes.</span>
    <span class="doccomment">/// This size can only be found out at runtime, which is the reason why we have to wrap this code in a `lazy_static` macro.</span>
    <span class="doccomment">/// Notice the use of the `ref` keyword; `DINODE_SIZE` is a reference to an `u64` number, that will only be filled in at runtime.</span>
    <span class="doccomment">/// Used to determine the number of inodes per block, which is important for filesystem initialization.</span>
    <span class="kw">pub</span> <span class="kw">static</span> <span class="kw-2">ref</span> <span class="ident">DINODE_SIZE</span> : <span class="ident">u64</span> <span class="op">=</span> <span class="ident">bincode</span>::<span class="ident">serialize</span>(<span class="kw-2">&amp;</span><span class="ident">DInode</span>::<span class="ident">default</span>()).<span class="ident">unwrap</span>().<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span>;
}

<span class="doccomment">/// Inode number of the root inode</span>
<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ROOT_INUM</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="number">1</span>;

<span class="doccomment">/// Wrapper around disk inodes `DInode` used for in-memory inodes.</span>
<span class="doccomment">/// Additionally contains the number of the inode `inum`.</span>
<span class="doccomment">/// This information is not required as long as the inode is stored on disk, as it is implicit from the block in which the inode is stored.</span>
<span class="doccomment">/// This is analogous to a [`Block`](../block/struct.Block.html) explicitly keeping track of its block number</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Inode</span> {
    <span class="doccomment">/// inode number</span>
    <span class="kw">pub</span> <span class="ident">inum</span>: <span class="ident">u64</span>,
    <span class="doccomment">/// the disk contents corresponding to `inum`</span>
    <span class="kw">pub</span> <span class="ident">disk_node</span>: <span class="ident">DInode</span>,
}

<span class="kw">impl</span> <span class="ident">Inode</span> {
    <span class="doccomment">/// Create a new inode</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">inum</span>: <span class="ident">u64</span>, <span class="ident">disk_node</span>: <span class="ident">DInode</span>) <span class="op">-&gt;</span> <span class="ident">Inode</span> {
        <span class="ident">Inode</span> { <span class="ident">inum</span>, <span class="ident">disk_node</span> }
    }
}

<span class="doccomment">/// Trait for inode-like behavior, so that we can have different inodes later on, without having to change the interfaces of the inode trait</span>
<span class="doccomment">/// Solely used in testing, so does not require setter methods</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">InodeLike</span>: <span class="ident">Sized</span> {
    <span class="doccomment">///Create a new inode from the given parameters</span>
    <span class="doccomment">///The user of this method is responsible for making sure that the parameters are consistent with each other and the rest of the code</span>
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">inum</span>: <span class="ident">u64</span>, <span class="ident">ft</span>: <span class="kw-2">&amp;</span><span class="ident">FType</span>, <span class="ident">nlink</span>: <span class="ident">u64</span>, <span class="ident">size</span>: <span class="ident">u64</span>, <span class="ident">blocks</span>: <span class="kw-2">&amp;</span>[<span class="ident">u64</span>]) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span>;
    <span class="doccomment">///Get the file type of this inode</span>
    <span class="kw">fn</span> <span class="ident">get_ft</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">FType</span>;
    <span class="doccomment">///Get the number of links to this inode in the file system</span>
    <span class="kw">fn</span> <span class="ident">get_nlink</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">u64</span>;
    <span class="doccomment">///Get the size of this inode in bytes</span>
    <span class="kw">fn</span> <span class="ident">get_size</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">u64</span>;
    <span class="doccomment">///Get the address of the *i*th block pointed to by this inode, if there is any block under index *i*</span>
    <span class="doccomment">///Note that this function&#39;s behavior is undefined for unallocated indexes `i` (as these are commonly set to 0). It is up to the caller to figure out whether the index *i* was sensible, based on `get_size()` and the external file system block size.</span>
    <span class="kw">fn</span> <span class="ident">get_block</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">i</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">u64</span>;
    <span class="doccomment">///Get the number of this inode on the disk</span>
    <span class="kw">fn</span> <span class="ident">get_inum</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">u64</span>;
}

<span class="doccomment">///You get the implementation of `InodeLike` for free for the `Inode` I defined above</span>
<span class="doccomment">///You will have to write different implemenations of this trait in case you complete the extra assignments.</span>
<span class="kw">impl</span> <span class="ident">InodeLike</span> <span class="kw">for</span> <span class="ident">Inode</span> {
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">inum</span>: <span class="ident">u64</span>, <span class="ident">ft</span>: <span class="kw-2">&amp;</span><span class="ident">FType</span>, <span class="ident">nlink</span>: <span class="ident">u64</span>, <span class="ident">size</span>: <span class="ident">u64</span>, <span class="ident">blocks</span>: <span class="kw-2">&amp;</span>[<span class="ident">u64</span>]) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="ident">nlink</span> <span class="op">&gt;</span> <span class="ident">u16</span>::<span class="ident">MAX</span> <span class="kw">as</span> <span class="ident">u64</span> {
            <span class="kw">return</span> <span class="prelude-val">None</span>;
        }
        <span class="kw">if</span> <span class="ident">blocks</span>.<span class="ident">len</span>() <span class="op">&gt;</span> <span class="ident">DIRECT_POINTERS</span> <span class="kw">as</span> <span class="ident">usize</span> {
            <span class="kw">return</span> <span class="prelude-val">None</span>;
        }

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">db</span> <span class="op">=</span> [<span class="number">0</span>; <span class="ident">DIRECT_POINTERS</span> <span class="kw">as</span> <span class="ident">usize</span>];
        <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">blocks</span>.<span class="ident">len</span>() {
            <span class="ident">db</span>[<span class="ident">i</span>] <span class="op">=</span> <span class="ident">blocks</span>[<span class="ident">i</span>];
        }

        <span class="kw">let</span> <span class="ident">di</span> <span class="op">=</span> <span class="ident">DInode</span> {
            <span class="ident">ft</span>: <span class="kw-2">*</span><span class="ident">ft</span>,
            <span class="ident">nlink</span>: <span class="ident">nlink</span> <span class="kw">as</span> <span class="ident">u16</span>,
            <span class="ident">size</span>,
            <span class="ident">direct_blocks</span>: <span class="ident">db</span>,
        };
        <span class="prelude-val">Some</span>(<span class="ident">Inode</span>::<span class="ident">new</span>(<span class="ident">inum</span>, <span class="ident">di</span>))
    }

    <span class="kw">fn</span> <span class="ident">get_ft</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">FType</span> {
        <span class="self">self</span>.<span class="ident">disk_node</span>.<span class="ident">ft</span>
    }
    <span class="kw">fn</span> <span class="ident">get_nlink</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">u64</span> {
        <span class="self">self</span>.<span class="ident">disk_node</span>.<span class="ident">nlink</span> <span class="kw">as</span> <span class="ident">u64</span>
    }
    <span class="kw">fn</span> <span class="ident">get_size</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">u64</span> {
        <span class="self">self</span>.<span class="ident">disk_node</span>.<span class="ident">size</span>
    }
    <span class="kw">fn</span> <span class="ident">get_block</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">i</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">u64</span> {
        <span class="kw">if</span> <span class="ident">DIRECT_POINTERS</span> <span class="op">&lt;=</span> <span class="ident">i</span> {
            <span class="kw">return</span> <span class="number">0</span>;
        }
        <span class="self">self</span>.<span class="ident">disk_node</span>.<span class="ident">direct_blocks</span>[<span class="ident">i</span> <span class="kw">as</span> <span class="ident">usize</span>]
    }

    <span class="kw">fn</span> <span class="ident">get_inum</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">u64</span> {
        <span class="self">self</span>.<span class="ident">inum</span>
    }
}

<span class="doccomment">/// Hard-coded number of characters each directory entry can contain for its name</span>
<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">DIRNAME_SIZE</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">14</span>;

<span class="doccomment">/// Specific type of inode contents for directories</span>
<span class="doccomment">/// A directory is a file containing a sequence of DirEntry structures, with the `FType` set to the directory type `TDir`.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">DirEntry</span> {
    <span class="doccomment">///Number of the inode this directory entry points to</span>
    <span class="doccomment">///It is these types of pointers that cause inode&#39;s `nlink` fields to increase in the file system</span>
    <span class="doccomment">///A directory entry with an `inum` of 0 represents an empty entry</span>
    <span class="kw">pub</span> <span class="ident">inum</span>: <span class="ident">u64</span>,
    <span class="doccomment">///Character array specifying the name of this entry\</span>
    <span class="doccomment">///Names can be up to `DIRNAME_SIZE` characters long\</span>
    <span class="doccomment">///Shorter names can be specified by storing the null termination character `\0` inside the array; this character indicates the end of the name string</span>
    <span class="doccomment">///Note that `char` in Rust is UTF-8 encoded and always takes up 4 bytes. This saves us headaches in the conversion below, at the cost of some memory efficiency</span>
    <span class="kw">pub</span> <span class="ident">name</span>: [<span class="ident">char</span>; <span class="ident">DIRNAME_SIZE</span>],
}

<span class="macro">lazy_static</span><span class="macro">!</span> {
    <span class="doccomment">/// Size of an directory entry in your system, in bytes.</span>
    <span class="doccomment">/// For similar reasons, again wrapped in the `lazy_static!` macro.</span>
    <span class="kw">pub</span> <span class="kw">static</span> <span class="kw-2">ref</span> <span class="ident">DIRENTRY_SIZE</span> : <span class="ident">u64</span> <span class="op">=</span> <span class="ident">bincode</span>::<span class="ident">serialize</span>(<span class="kw-2">&amp;</span><span class="ident">DirEntry</span>::<span class="ident">default</span>()).<span class="ident">unwrap</span>().<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span>;
}

<span class="doccomment">///Tests for the block type</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">block_tests</span> {

    <span class="kw">use</span> <span class="kw">super</span>::<span class="ident">Block</span>;
    <span class="kw">use</span> <span class="ident">serde</span>::{<span class="ident">Deserialize</span>, <span class="ident">Serialize</span>};

    <span class="comment">// For these tests, we use blocks containing 1000 bytes, which should be enough to store a few inodes</span>
    <span class="kw">static</span> <span class="ident">BLOCK_SIZE</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="number">1000</span>;

    <span class="comment">//Testing the raw read/write methods offered by blocks</span>
    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">raw_rw_test</span>() {
        <span class="kw">let</span> <span class="ident">n1</span> <span class="op">=</span> <span class="number">12</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">b1</span> <span class="op">=</span> <span class="ident">Block</span>::<span class="ident">new_zero</span>(<span class="ident">n1</span>, <span class="ident">BLOCK_SIZE</span>);
        <span class="comment">//Contents have been installed correctly</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">contents_as_ref</span>(), <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="ident">BLOCK_SIZE</span> <span class="kw">as</span> <span class="ident">usize</span>]);

        <span class="comment">//Write and then reread some raw data</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">raw_data</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>; <span class="number">5</span>];
        <span class="ident">b1</span>.<span class="ident">write_data</span>(<span class="kw-2">&amp;</span><span class="ident">raw_data</span>, <span class="number">10</span>).<span class="ident">unwrap</span>();
        <span class="ident">b1</span>.<span class="ident">read_data</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">raw_data</span>, <span class="number">8</span>).<span class="ident">unwrap</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">raw_data</span>, <span class="macro">vec</span><span class="macro">!</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>));

        <span class="comment">//Try to read or write out of bounds</span>
        <span class="comment">//Trivial out of bounds</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">emp</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
        <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">write_data</span>(<span class="kw-2">&amp;</span><span class="ident">emp</span>, <span class="ident">BLOCK_SIZE</span>).<span class="ident">is_ok</span>()); <span class="comment">//double check</span>
        <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">write_data</span>(<span class="kw-2">&amp;</span><span class="ident">emp</span>, <span class="ident">BLOCK_SIZE</span> <span class="op">+</span> <span class="number">1</span>).<span class="ident">is_err</span>());
        <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">read_data</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">emp</span>, <span class="ident">BLOCK_SIZE</span> <span class="op">+</span> <span class="number">1</span>).<span class="ident">is_err</span>());
        <span class="comment">//Read or write out of bounds because of buffer size</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">one</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>];
        <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">write_data</span>(<span class="kw-2">&amp;</span><span class="ident">one</span>, <span class="ident">BLOCK_SIZE</span>).<span class="ident">is_err</span>());
        <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">read_data</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">one</span>, <span class="ident">BLOCK_SIZE</span>).<span class="ident">is_err</span>());
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">two</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>];
        <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">write_data</span>(<span class="kw-2">&amp;</span><span class="ident">two</span>, <span class="ident">BLOCK_SIZE</span> <span class="op">-</span> <span class="number">1</span>).<span class="ident">is_err</span>());
        <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">read_data</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">two</span>, <span class="ident">BLOCK_SIZE</span> <span class="op">-</span> <span class="number">1</span>).<span class="ident">is_err</span>());
    }

    <span class="comment">//Importing some example deserializable struct</span>
    <span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">types</span>::{<span class="ident">DInode</span>, <span class="ident">FType</span>, <span class="ident">DINODE_SIZE</span>, <span class="ident">DIRECT_POINTERS</span>};
    <span class="comment">//Another testing struct to perform (de)serialization on</span>
    <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
    <span class="kw">struct</span> <span class="ident">Point</span>(<span class="ident">u64</span>, <span class="ident">u64</span>);

    <span class="comment">//Testing the (de)serialization methods offered by blocks</span>
    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">serialization_test</span>() {
        <span class="kw">let</span> <span class="ident">p1</span> <span class="op">=</span> <span class="ident">Point</span>(<span class="number">0</span>, <span class="number">0</span>);
        <span class="kw">let</span> <span class="ident">p2</span> <span class="op">=</span> <span class="ident">Point</span>(<span class="number">1000</span>, <span class="number">1000</span>);
        <span class="kw">let</span> <span class="ident">in1</span> <span class="op">=</span> <span class="ident">DInode</span>::<span class="ident">default</span>();
        <span class="kw">let</span> <span class="ident">in2</span> <span class="op">=</span> <span class="ident">DInode</span> {
            <span class="ident">ft</span>: <span class="ident">FType</span>::<span class="ident">TFree</span>,
            <span class="ident">nlink</span>: <span class="number">13</span>,
            <span class="ident">size</span>: <span class="number">142</span>,
            <span class="ident">direct_blocks</span>: [<span class="number">1000</span>; <span class="ident">DIRECT_POINTERS</span> <span class="kw">as</span> <span class="ident">usize</span>],
        };

        <span class="comment">//Testing some length consistency, and the global variable DINODE_SIZE</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(
            <span class="ident">bincode</span>::<span class="ident">serialize</span>(<span class="kw-2">&amp;</span><span class="ident">p1</span>).<span class="ident">unwrap</span>().<span class="ident">len</span>(),
            <span class="ident">bincode</span>::<span class="ident">serialize</span>(<span class="kw-2">&amp;</span><span class="ident">p1</span>).<span class="ident">unwrap</span>().<span class="ident">len</span>()
        );
        <span class="macro">assert_eq</span><span class="macro">!</span>(
            <span class="ident">bincode</span>::<span class="ident">serialize</span>(<span class="kw-2">&amp;</span><span class="ident">in1</span>).<span class="ident">unwrap</span>().<span class="ident">len</span>(),
            <span class="kw-2">*</span><span class="ident">DINODE_SIZE</span> <span class="kw">as</span> <span class="ident">usize</span>
        );
        <span class="macro">assert_eq</span><span class="macro">!</span>(
            <span class="ident">bincode</span>::<span class="ident">serialize</span>(<span class="kw-2">&amp;</span><span class="ident">in1</span>).<span class="ident">unwrap</span>().<span class="ident">len</span>(),
            <span class="ident">bincode</span>::<span class="ident">serialize</span>(<span class="kw-2">&amp;</span><span class="ident">in2</span>).<span class="ident">unwrap</span>().<span class="ident">len</span>()
        );

        <span class="kw">let</span> <span class="ident">n1</span> <span class="op">=</span> <span class="number">12</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">b1</span> <span class="op">=</span> <span class="ident">Block</span>::<span class="ident">new</span>(<span class="ident">n1</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="ident">BLOCK_SIZE</span> <span class="kw">as</span> <span class="ident">usize</span>].<span class="ident">into_boxed_slice</span>());
        <span class="kw">let</span> <span class="ident">point_size</span> <span class="op">=</span> <span class="ident">bincode</span>::<span class="ident">serialize</span>(<span class="kw-2">&amp;</span><span class="ident">p1</span>).<span class="ident">unwrap</span>().<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span>;
        <span class="comment">//Now perform some actual writes to the block, and read them again after</span>
        <span class="ident">b1</span>.<span class="ident">serialize_into</span>(<span class="kw-2">&amp;</span><span class="ident">p1</span>, <span class="number">0</span>).<span class="ident">unwrap</span>();
        <span class="ident">b1</span>.<span class="ident">serialize_into</span>(<span class="kw-2">&amp;</span><span class="ident">p2</span>, <span class="ident">point_size</span>).<span class="ident">unwrap</span>();
        <span class="ident">b1</span>.<span class="ident">serialize_into</span>(<span class="kw-2">&amp;</span><span class="ident">in1</span>, <span class="number">2</span> <span class="op">*</span> <span class="ident">point_size</span>).<span class="ident">unwrap</span>();
        <span class="ident">b1</span>.<span class="ident">serialize_into</span>(<span class="kw-2">&amp;</span><span class="ident">in2</span>, <span class="number">2</span> <span class="op">*</span> <span class="ident">point_size</span> <span class="op">+</span> <span class="kw-2">*</span><span class="ident">DINODE_SIZE</span>)
            .<span class="ident">unwrap</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">deserialize_from</span>::<span class="op">&lt;</span><span class="ident">Point</span><span class="op">&gt;</span>(<span class="number">0</span>).<span class="ident">unwrap</span>(), <span class="ident">p1</span>);
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">deserialize_from</span>::<span class="op">&lt;</span><span class="ident">Point</span><span class="op">&gt;</span>(<span class="ident">point_size</span>).<span class="ident">unwrap</span>(), <span class="ident">p2</span>);
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">deserialize_from</span>::<span class="op">&lt;</span><span class="ident">DInode</span><span class="op">&gt;</span>(<span class="number">2</span> <span class="op">*</span> <span class="ident">point_size</span>).<span class="ident">unwrap</span>(), <span class="ident">in1</span>);
        <span class="macro">assert_eq</span><span class="macro">!</span>(
            <span class="ident">b1</span>.<span class="ident">deserialize_from</span>::<span class="op">&lt;</span><span class="ident">DInode</span><span class="op">&gt;</span>(<span class="number">2</span> <span class="op">*</span> <span class="ident">point_size</span> <span class="op">+</span> <span class="kw-2">*</span><span class="ident">DINODE_SIZE</span>)
                .<span class="ident">unwrap</span>(),
            <span class="ident">in2</span>
        );

        <span class="comment">//Perform reads and writes that go out of bounds</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">b1</span> <span class="op">=</span> <span class="ident">Block</span>::<span class="ident">new_zero</span>(<span class="ident">n1</span>, <span class="ident">BLOCK_SIZE</span>);
        <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">b1</span>
            .<span class="ident">deserialize_from</span>::<span class="op">&lt;</span><span class="ident">Point</span><span class="op">&gt;</span>(<span class="ident">BLOCK_SIZE</span> <span class="op">+</span> <span class="number">1</span> <span class="op">-</span> <span class="ident">point_size</span>)
            .<span class="ident">is_err</span>());
        <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">serialize_into</span>(<span class="kw-2">&amp;</span><span class="ident">p2</span>, <span class="ident">BLOCK_SIZE</span> <span class="op">+</span> <span class="number">1</span> <span class="op">-</span> <span class="ident">point_size</span>).<span class="ident">is_err</span>());
        <span class="comment">//Ensure contents don&#39;t change after faulty reads or writes</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">b1</span>.<span class="ident">contents_as_ref</span>(), <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="ident">BLOCK_SIZE</span> <span class="kw">as</span> <span class="ident">usize</span>]);
    }
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "cplfs_api";</script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script></body></html>