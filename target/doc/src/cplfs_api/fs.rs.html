<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `api/src/fs.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>fs.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../cplfs_api/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">//! Collection of all traits you will be implementing throughout the different assignments</span>
<span class="doccomment">//! Each file system must at least implement the `FileSysSupport` trait.</span>
<span class="doccomment">//! Do not just blindly implement the below traits; in most cases, it is a good idea to define auxiliary functions, to e.g. figure out in what block inode $i$ is stored, how many directory entries fit in a block, or to read a specific byte from a block.</span>
<span class="doccomment">//! Make sure your implementation provides auxiliary functions for repetitive tasks like these.</span>
<span class="doccomment">//! You might need to wrap (some of) the types I provided in the API into your own types, to be able to define additional behavior on them.</span>

<span class="kw">use</span> <span class="kw">super</span>::{
    <span class="ident">controller</span>::<span class="ident">Device</span>,
    <span class="ident">types</span>::{<span class="ident">Block</span>, <span class="ident">Buffer</span>, <span class="ident">DirEntry</span>, <span class="ident">FType</span>, <span class="ident">InodeLike</span>, <span class="ident">SuperBlock</span>},
};
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">error</span>, <span class="ident">path</span>::<span class="ident">Path</span>};

<span class="doccomment">/// General trait that each filesystem should implement, that allows us to set up, tear down and load file systems in the tests</span>
<span class="doccomment">/// Additionally, this trait also defines the error type that is used in all of the other traits (which will require implementing this trait)</span>
<span class="doccomment">/// Be warned that the implementation of this trait cannot be kept the same throughout the assignment!</span>
<span class="doccomment">/// Depending on the abstractions your current file system is aware of, it might impose more strict conditions when loading a file system, and might perform extra steps when defining one.</span>
<span class="doccomment">/// For example, when implementing the block layer for your file system, it should not create a root inode as part of `mkfs`, and neither should it check for one when mounting an existing file system. These steps should only be implemented at higher levels of abstraction.</span>
<span class="doccomment">/// In other words, you should *not* have one blanket implementation of this trait for your entire project, and it will be beneficial to you when e.g. defining the inode abstraction, to take your solution from the block layer, including its implementation of this trait, and create a wrapper around it that (re)implements this and any other relevant traits, so that you can delegate calls to this trait to the wrapped object, and define extra steps on top of them.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Consult the documentation of [`SuperBlock`](../types/struct.SuperBlock.html) for more detailed information on the proper layout of the file system and the meaning of the different superblock components</span>
<span class="doccomment">///</span>
<span class="doccomment">/// *HINT*: consider caching your filesystem superblock when creating or loading a file system, so you do not have to read it each time you need it</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">FileSysSupport</span>: <span class="ident">Sized</span> {
    <span class="doccomment">/// The type of the errors of your implementation.</span>
    <span class="doccomment">/// Read more about how to define your own errors in the documentation of [`error_given`](../error_given/index.html).</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Note the “supertrait” your error type must implement:</span>
    <span class="doccomment">/// [`error::Error`](https://doc.rust-lang.org/std/error/trait.Error.html)</span>
    <span class="doccomment">/// This is the base trait for all Rust errors, click</span>
    <span class="doccomment">/// on it to see the methods you must implement.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Note that you can use the same error type for multiple parts of the assignment.</span>
    <span class="kw">type</span> <span class="ident">Error</span>: <span class="ident">error</span>::<span class="ident">Error</span>;

    <span class="doccomment">/// Static method to check if a given superblock represents a valid file system.</span>
    <span class="doccomment">/// You will need this both when creating a new file system, and loading an existing one from disk</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// More concretely, the following conditions need to hold to make a `SuperBlock` a possibly valid representation of a file system</span>
    <span class="doccomment">/// - the regions have to appear in the right order</span>
    <span class="doccomment">/// - the regions have to be sufficiently large to hold `ninodes` inodes (calculated using the size of your inodes) and to hold and keep track of `ndatablocks` datablocks</span>
    <span class="doccomment">/// - the regions have to physically fit on the disk together, i.e. fall within the first `nblocks` blocks</span>
    <span class="kw">fn</span> <span class="ident">sb_valid</span>(<span class="ident">sb</span>: <span class="kw-2">&amp;</span><span class="ident">SuperBlock</span>) <span class="op">-&gt;</span> <span class="ident">bool</span>;

    <span class="doccomment">/// Method to create and mount a new file system from scratch, given a super block (which is a bit more convenient to work with than a bunch of parameters) and a path.</span>
    <span class="doccomment">/// What exactly this method does, depends on the level of abstraction you are implementing.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This method always does the following, regardless of the layer of abstraction:</span>
    <span class="doccomment">/// - Check if the given superblock is a valid file system superblock</span>
    <span class="doccomment">/// - Create a new `Device` at the given path, to allow the file system to communicate with it</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Then, subdivide the freshly created device image into the previously described regions:</span>
    <span class="doccomment">/// 1. A super block containing the file system metadata at block index 0</span>
    <span class="doccomment">/// 2. *This is only relevant for the inode layer and up, i.e. ignore this set-up step in the disk block layer.*</span>
    <span class="doccomment">///    A list of blocks containing inodes, where all inodes as marked as &quot;free&quot; (since they are free, the rest of their contents is irrelevant and hence unspecified).\</span>
    <span class="doccomment">/// *You only need to do the following once you support directories:*</span>
    <span class="doccomment">/// The first inode (with number 1) describes the &quot;root path&quot;, i.e. the path &quot;/&quot; on UNIX systems. It is initially empty, i.e. has no directory entries inside it.</span>
    <span class="doccomment">/// The root node has its `nlink` field set to 1 from the start, even though there are no references to it, so that it cannot be deallocated.</span>
    <span class="doccomment">/// Note that inodes start counting at one, and *NOT* at zero, to avoid confusion with the error return value 0 in the kernel.</span>
    <span class="doccomment">/// However, to avoid off-by-1 errors, room for inode 0 is still allocated in the first inode block on disk (i.e. inode 1 is *not* stored at address 0 of this block).</span>
    <span class="doccomment">/// This space will under normal circumstances never be used.</span>
    <span class="doccomment">/// 3. A bitmap keeping track of the occupied memory blocks.</span>
    <span class="doccomment">/// This bitmap should initially mark all blocks as &quot;free&quot;, as no block allocations have happened.</span>
    <span class="doccomment">/// 4. A data region to contain the memory blocks themselves</span>
    <span class="doccomment">/// Since all blocks are marked as free after initialization and allocating a block should set its contents to 0, the contents of this region is unimportant.</span>
    <span class="doccomment">/// This data region is assumed to run until the end of the file system.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Think about whether the initial `Device` you create inside this method, which will contain 0 at each address (see the [documentation](../controller/struct.Device.html#method.new)), is a valid disk representation, or if it requires extra initialization for one or more of the above regions.</span>
    <span class="doccomment">/// (*Hint for the inode layer and up*: watch out for the inodes; an all-0 inode will not necessarily come out well during deserialization, and probably needs to be overwritten by an actually free inode)</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Make sure your underlying device is in a consistent state and matches the above enumeration at the end of this function.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *IMPORTANT NOTE*: In case you need to loop over inodes here or anywhere else in this project, do so **efficiently**, i.e. if you need to read/write multiple inodes in the same block, only load and store this block once!</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *EXTRA*: mkfs is inspired by the unix command of the same name (although this version also immediately mounts the file system)</span>
    <span class="kw">fn</span> <span class="ident">mkfs</span><span class="op">&lt;</span><span class="ident">P</span>: <span class="ident">AsRef</span><span class="op">&lt;</span><span class="ident">Path</span><span class="op">&gt;&gt;</span>(<span class="ident">path</span>: <span class="ident">P</span>, <span class="ident">sb</span>: <span class="kw-2">&amp;</span><span class="ident">SuperBlock</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Given an existing `Device` called `dev`, make sure that its image corresponds to a valid file system by reading its superblock and checking the following conditions:</span>
    <span class="doccomment">/// - The superblock is a valid superblock</span>
    <span class="doccomment">/// - The block size and number of blocks of the device and superblock agree</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If these conditions are satisfied, wrap the given `Device` in a file system and return it.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// You do **not** need to deserialize each individual object in each region to check that it is indeed a valid object; to keep matters simple, we will assume that the contents of each region has been properly initialized.</span>
    <span class="doccomment">/// Additionally, we could add `dev` to the return type to reclaim ownership in case of an error, but we do not bother recovering invalid devices, for simplicity reasons.</span>
    <span class="kw">fn</span> <span class="ident">mountfs</span>(<span class="ident">dev</span>: <span class="ident">Device</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Unmount the give file system, thereby consuming it</span>
    <span class="doccomment">/// Returns the image of the file system, i.e. the `Device` backing it.</span>
    <span class="doccomment">/// The implementation of this method should be almost trivial</span>
    <span class="kw">fn</span> <span class="ident">unmountfs</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Device</span>;
}

<span class="doccomment">/// This trait adds block-level operations to your file system</span>
<span class="doccomment">/// Do not forget to make sure that `mkfs` now correctly initializes all inodes, as described above.</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">BlockSupport</span>: <span class="ident">FileSysSupport</span> {
    <span class="doccomment">/// Read the *n*th block *of the entire disk* and return it\</span>
    <span class="doccomment">/// The implementation of this method should be trivial</span>
    <span class="kw">fn</span> <span class="ident">b_get</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">i</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Block</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Write the *n*th block *of the entire disk* and return it\</span>
    <span class="doccomment">/// The implementation of this method should be trivial</span>
    <span class="kw">fn</span> <span class="ident">b_put</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">b</span>: <span class="kw-2">&amp;</span><span class="ident">Block</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Free the *i*th block *in the block data region*, by setting the *i*th bit in the free bit map region to zero.</span>
    <span class="doccomment">/// To disambiguate the binary representation, we define the order of the bits within each byte you read from right to left, i.e. the byte &#39;0b0000_0001&#39; has its **first** bit set to one, i.e. has its bit with index 0 set to 1.</span>
    <span class="doccomment">/// Be careful not to change any bits for other blocks around the *i*th block by overwriting an entire byte in the free bit map region!</span>
    <span class="doccomment">/// Consider writing some auxiliary methods for more fine-grained access to `Block`s, by wrapping the provided block type in a different type.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Remember that you *cannot* access memory on a per-bit basis!</span>
    <span class="doccomment">/// The bitwise operators `&amp;` (bitwise AND), `|` (bitwise OR), `^` (bitwise XOR) exist; use those, together with the bit-shift operators `&gt;&gt;` and `&lt;&lt;`, to change the correct bit (or use an external, stable crate).</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the *i*th block is already a free block, the state of memory should not change, and this method should return an error</span>
    <span class="doccomment">/// Also errors if the index *i* is out of bounds, i.e. if it is higher than the number of data blocks</span>
    <span class="kw">fn</span> <span class="ident">b_free</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">i</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Zeroes the *i*th block *in the block data region* in memory (without freeing it)\</span>
    <span class="doccomment">/// Errors if the index *i* is out of bounds, i.e. if it is higher than the number of data blocks</span>
    <span class="kw">fn</span> <span class="ident">b_zero</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">i</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Allocate the first free block, starting from the beginning, in the data block region, thereby setting its bit in the bitmap region to one and the entire contents of the block to zero.</span>
    <span class="doccomment">/// Again, you will need bit-wise operators to implement this function.</span>
    <span class="doccomment">/// Obviously, only blocks that have not been allocated yet, i.e. do not have their bit set, can still be allocated.</span>
    <span class="doccomment">/// Returns the index (*within the data region*) of the newly allocated block.</span>
    <span class="doccomment">/// Make sure to load each *bitmap* block only once in your implementation.</span>
    <span class="doccomment">/// Errors appropriately if no blocks are available.</span>
    <span class="kw">fn</span> <span class="ident">b_alloc</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u64</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Get the superblock describing the current file system</span>
    <span class="kw">fn</span> <span class="ident">sup_get</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">SuperBlock</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Write the superblock to this file system&#39;s underlying device (and cache it, depending on how you implement your file system)</span>
    <span class="doccomment">/// Note that in general, when you write to a block, you read the block first and then overwrite the parts you need to change before writing it back, to make sure all other parts of the block remain unchanged.</span>
    <span class="doccomment">/// In this case, that is not strictly necessary, as the superblock is the only useful thing that is stored on the first disk block.</span>
    <span class="doccomment">/// However, in case other data were to be stored past the superblock struct in the future, do implement this function in this conservative way.</span>
    <span class="kw">fn</span> <span class="ident">sup_put</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">sup</span>: <span class="kw-2">&amp;</span><span class="ident">SuperBlock</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;
}

<span class="doccomment">/// This trait adds the abstraction of inodes to your file system.</span>
<span class="doccomment">/// Do not forget that `mkfs` should now result in a filesystem where each inode is marked as free.</span>
<span class="doccomment">/// Note that this trait does not yet support ways of growing inodes.</span>
<span class="doccomment">/// Growing inodes will become possible when you implement the read and write calls on them in one of the optional assignments.</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">InodeSupport</span>: <span class="ident">BlockSupport</span> {
    <span class="doccomment">/// The type you use for your inodes at runtime. Initially, you can probably get away with [the inode type I provided](../inode/struct.Inode.html).</span>
    <span class="doccomment">/// In the extensions, we can replace this type with a different type of inode that provides more flexibility (e.g. aliasing behavior, and a variable number of blocks)</span>
    <span class="kw">type</span> <span class="ident">Inode</span>: <span class="ident">InodeLike</span>;

    <span class="doccomment">/// Read the disk inode with index `i` and wrap it into an inode object.</span>
    <span class="doccomment">/// Should error if `i` is greater than the number of inodes in the system.</span>
    <span class="kw">fn</span> <span class="ident">i_get</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">i</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Inode</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Write the given inode back to the disk at the correct position</span>
    <span class="kw">fn</span> <span class="ident">i_put</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">ino</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Inode</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Similar to b_free, but now for inodes instead of data blocks.</span>
    <span class="doccomment">/// A big difference is that this method should only free an inode if it is no longer referenced anywhere else in the file system, i.e. if its `nlink` field is equal to zero.</span>
    <span class="doccomment">/// In this case, the $i$th inode in the inode region is freed by setting its `ft` field to `TFree`.</span>
    <span class="doccomment">/// Additionally, all valid blocks belonging to this file, listed in its `direct_blocks` array, have to be deallocated (and set to address 0) as well.</span>
    <span class="doccomment">/// In case `nlink` is not equal to zero, this method does nothing.</span>
    <span class="doccomment">/// Returns an error if `i` does not correspond to an inode number, or if the inode is already free.</span>
    <span class="kw">fn</span> <span class="ident">i_free</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">i</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Similar to b_alloc, but now for inodes instead of data</span>
    <span class="doccomment">/// Allocates the first free `dinode` (i.e. lowest `inum`) it comes across, and sets (on disk):</span>
    <span class="doccomment">///  - this inode&#39;s `FType` to `ft`</span>
    <span class="doccomment">///  - this inode&#39;s `size` and `nlink` fields to 0, as it currently has no blocks and is not referenced in the file system</span>
    <span class="doccomment">/// The inode with index 0 should *never* be allocated.</span>
    <span class="doccomment">/// Errors appropriately if no inodes are available</span>
    <span class="doccomment">/// Only read each inode block once in your implementation</span>
    <span class="kw">fn</span> <span class="ident">i_alloc</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">ft</span>: <span class="ident">FType</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u64</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Truncate the given `inode`, i.e. release its contents (without freeing it).</span>
    <span class="doccomment">/// Sets all of the given inode&#39;s `direct_blocks` to point to address 0.</span>
    <span class="doccomment">/// Releases all blocks `direct_blocks` belonging to this inode, and sets its `size` to 0.</span>
    <span class="doccomment">/// Changes both the given `inode` and the corresponding inode on the disk.</span>
    <span class="doccomment">/// Note that only the valid blocks should be released as only these are allocated. In other words, do not blindly release all values listed in the `direct_blocks` field</span>
    <span class="kw">fn</span> <span class="ident">i_trunc</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">inode</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">Self</span>::<span class="ident">Inode</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;
}

<span class="doccomment">///This trait additionally provides support to read and write from inodes using buffers; the data structure that we used before to hold the contents of a `Block`.</span>
<span class="doccomment">///The reason we use `Buffer`s objects and not simply the raw data, is because `Buffer`s also support some methods relating to (de)serialization, which might come in handy in some situations.</span>
<span class="doccomment">/// We ignore arithmetic over- and underflow in the following functions, for reasons of simplicity.</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">InodeRWSupport</span>: <span class="ident">InodeSupport</span> {
    <span class="doccomment">/// Read `n` bytes of data from inode `inode` into the given buffer `buf`, starting from byte offset `off` in the inode `inode`</span>
    <span class="doccomment">/// Returns the amount of bytes read, so that clients of this function can check if something went wrong</span>
    <span class="doccomment">/// If the end of the file is reached while reading, stop reading.</span>
    <span class="doccomment">/// If a read starts at `inode.get_size()`, returns with 0 bytes read.</span>
    <span class="doccomment">/// By contrast, returns an error and does not read anything in case the provided index falls further outside of the file&#39;s bounds.</span>
    <span class="doccomment">///If `buf` cannot hold `n` bytes of data, reads until `buf` is full instead.</span>
    <span class="kw">fn</span> <span class="ident">i_read</span>(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        <span class="ident">inode</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Inode</span>,
        <span class="ident">buf</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Buffer</span>,
        <span class="ident">off</span>: <span class="ident">u64</span>,
        <span class="ident">n</span>: <span class="ident">u64</span>,
    ) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u64</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Write `n` bytes of data from the given buffer `buff` into the inode `inode`, starting from byte offset `off`</span>
    <span class="doccomment">/// If the end of the file is reached while writing, **continue writing**.</span>
    <span class="doccomment">/// If necessary, start allocating extra blocks to expand the file and continue writing into the new blocks.</span>
    <span class="doccomment">/// However, returns 0 and does not write anything in case the provided offset falls outside of the file&#39;s bounds.</span>
    <span class="doccomment">/// If the inode changes while writing, do not forget to write it back to the disk too.</span>
    <span class="doccomment">/// Returns an error if `buf` cannot hold at least `n` bytes of data.</span>
    <span class="doccomment">/// If the write would make the inode exceed its maximum possible size, do nothing and return an error.</span>
    <span class="kw">fn</span> <span class="ident">i_write</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">inode</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">Self</span>::<span class="ident">Inode</span>,
        <span class="ident">buf</span>: <span class="kw-2">&amp;</span><span class="ident">Buffer</span>,
        <span class="ident">off</span>: <span class="ident">u64</span>,
        <span class="ident">n</span>: <span class="ident">u64</span>,
    ) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;
}

<span class="doccomment">///This trait adds the abstraction of directories and their entries to the file system</span>
<span class="doccomment">/// Additionally, it supports some convenience methods that allow you to use directory entries with string names (the reason these methods are defined here and not in a trait, is to avoid forcing you to wrap the `DirEntry` type in another type of your own).</span>
<span class="doccomment">///Do not forget to make sure that `mkfs` now defines a valid (currently empty) root directory.</span>
<span class="doccomment">///</span>
<span class="doccomment">///Note that `i_free` is possibly unsafe for directories; if the freed directory is the last one to point to some entry and we free the directory&#39;s inode, the entry will be left dangling.</span>
<span class="doccomment">///To combat this, system calls will never call `i_free` directly, but rather call wrapper methods such as e.g. `unlink` (see the [`PathSupport`] trait and optional assignment for more information), to check all the necessary preconditions.</span>
<span class="doccomment">///The standard directory entries of &quot;..&quot; and &quot;.&quot;, that are present in any directory but the parent directory, will be implemented as part of the [`PathSupport`] extension too.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`PathSupport`]: ../fs/trait.PathSupport.html</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">DirectorySupport</span>: <span class="ident">InodeSupport</span> {
    <span class="doccomment">/// Create a new directory entry, given `inum` and `name`</span>
    <span class="doccomment">/// Returns `None` if an invalid name is provided</span>
    <span class="doccomment">/// Uses `set_name_str` to set the directory entry name</span>
    <span class="kw">fn</span> <span class="ident">new_de</span>(<span class="ident">inum</span>: <span class="ident">u64</span>, <span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">DirEntry</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Get the name of this directory entry as a `String`</span>
    <span class="doccomment">/// Loop over the characters in the direntry&#39;s name until you encounter a final character `\0` OR until you reach the end of the character array, and return the concatenation of these characters as the `Direntry`&#39;s name.</span>
    <span class="kw">fn</span> <span class="ident">get_name_str</span>(<span class="ident">de</span>: <span class="kw-2">&amp;</span><span class="ident">DirEntry</span>) <span class="op">-&gt;</span> <span class="ident">String</span>;

    <span class="doccomment">/// Set the name of this directory entry to the given `name`, if the given name is valid, i.e. it is</span>
    <span class="doccomment">///- non-empty</span>
    <span class="doccomment">///- consists of alphanumeric characters only, or is equal to &quot;.&quot; or &quot;..&quot;</span>
    <span class="doccomment">///- is sufficiently short when converted to characters</span>
    <span class="doccomment">/// If the `name` is shorter than `DIRNAME_SIZE`, insert a &#39;\0&#39; at the end so you can still correctly read it after.</span>
    <span class="doccomment">/// Returns `None` in case of an invalid name</span>
    <span class="kw">fn</span> <span class="ident">set_name_str</span>(<span class="ident">de</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">DirEntry</span>, <span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span>()<span class="op">&gt;</span>;

    <span class="doccomment">/// Look for a directory entry named `name` in a given inode, representing a directory.</span>
    <span class="doccomment">///Make sure that the `inode` you are calling this function with is up to date wrt. the one on disk!</span>
    <span class="doccomment">/// If found, return the `inode` corresponding to this directory entry, and the byte offset (from the start of the inode contents) it was found at, as a pair.</span>
    <span class="doccomment">/// Only inspects directory entries that fall within the `size` of the given `inode`. Errors if the given `inode` is not of directory type.</span>
    <span class="doccomment">/// If the entry is not found, return a suitable error that you can handle later, in the implementation of `dirlink` below.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// NOTE: self is mutably borrowed here because might want to call iget</span>
    <span class="kw">fn</span> <span class="ident">dirlookup</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">inode</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Inode</span>, <span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>)
        <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(<span class="self">Self</span>::<span class="ident">Inode</span>, <span class="ident">u64</span>), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Write a new directory entry with contents `name` and `inum` into the directory represented by `inode`.</span>
    <span class="doccomment">///Make sure that the `inode` you are calling this function with is up to date wrt. the one on disk!</span>
    <span class="doccomment">/// In case the directory has no free entries, append a new entry to the end and increase the size of `inode`. This might require allocating a new block as well.</span>
    <span class="doccomment">/// In case you implemented the optional `InodeRWSupport` assignment already , you could use the `i_write` method here.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// When a place for the given `inode` is found, looks up the inode corresponding to `inum` and increase its `nlink` field with 1 on disk (unless `inum` and `inode`&#39;s number are equal, then nothing happens, as this is a self-reference).</span>
    <span class="doccomment">/// Errors if</span>
    <span class="doccomment">/// - `name` is invalid, or is already an entry inside `inode`.</span>
    <span class="doccomment">/// - `inode` is not a directory.</span>
    <span class="doccomment">/// - errors *and does nothing* if the inode corresponding to `inum` is not currently in use.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Returns the byte offset at which the entry was written into the given `inode`</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *EXTRA*:In our model, we do not have to worry about hardlink-loops in our file system tree, as we currently provide no way of duplicating inodes.</span>
    <span class="kw">fn</span> <span class="ident">dirlink</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">inode</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">Self</span>::<span class="ident">Inode</span>,
        <span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>,
        <span class="ident">inum</span>: <span class="ident">u64</span>,
    ) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u64</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;
}

<span class="doccomment">///Enhance the previous directory support with a notion of file paths (both absolute and relative), enabling the following:</span>
<span class="doccomment">///- Allows looking up inodes along file paths, to allow for easier navigation.</span>
<span class="doccomment">///- Allows creating and unlinking (i.e. removing) directories at a given path location. The previously implemented `i_alloc` and `i_free` suffice for regular files, but can result in inconsistencies for directories.</span>
<span class="doccomment">///- Keeps track of the current working directory in your file system (pick an appropriate type to do this! **WARNING: give this some thought **). Usually, each process has its own current working directory, but since we only model a single process, we just store the current working directory in the file system.</span>
<span class="doccomment">///</span>
<span class="doccomment">///Do not forget to adapt the call to `mkfs`, so that the root directory is no longer empty, but like all other directories, gets initialized with &quot;.&quot; and &quot;..&quot; as its first two entries. The root directory is a special case, however, in the sense that &quot;..&quot; also points back to the root directory itself, since it has no parent.</span>
<span class="doccomment">///Make sure the `nlink` field of the root directory is equal to 1 still, after the initialization phase.</span>
<span class="doccomment">///Additionally, both the `mkfs` and `mountfs` calls initialize the current working directory to the root directory.</span>
<span class="doccomment">///</span>
<span class="doccomment">///**IMPORTANT**</span>
<span class="doccomment">/// for this assignment;</span>
<span class="doccomment">/// - We assume that none of the directories involved in the cwd&#39;s path will be deleted while we are in this directory. We do not check this at any point, nor do we lock any of those files or increase their `nlink`; we just assume that it will not happen. Additionally, we do not check that the cwd actually also exists in the file system; this is the responsibility of our clients</span>
<span class="doccomment">/// - In general, it is **not** necessarily the case the parent of a directory is the previous directory in the path!</span>
<span class="doccomment">/// For example, starting from `/test` then following the path `../alternative` by reading the file system, does not necessarily have us end up in `/alternative`. The reason is that the parent of `test` might be some different directory entirely, because the `dirlink` method below allows us to re-register inodes in different directories.</span>
<span class="doccomment">/// **However**, you can assume that the parent of the cwd **is** the previous directory in the path when appending a relative path in the `set_cwd` method. This is also how terminals usually operate when e.g. following symbolic links and then running `cd ..`, in order not to confuse users.</span>
<span class="doccomment">/// That being said, any paths provided to other methods than `set_cwd` **should go through the file system**, i.e. read &quot;..&quot; at each point to figure out what the actual parent inode is.</span>
<span class="doccomment">/// If this explanation is unclear to you, consult the tests provided with the assignment</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">PathSupport</span>: <span class="ident">DirectorySupport</span> {
    <span class="doccomment">/// Returns true iff the given string represents a valid path</span>
    <span class="doccomment">/// We support two different path formats:</span>
    <span class="doccomment">/// - *absolute paths* start with the character &quot;/&quot; and specify a path starting from the root node</span>
    <span class="doccomment">/// - *relative paths* start with &quot;.&quot; or &quot;..&quot; and denote respectively a path starting from the current working directory, and a path starting from the parent of the current working directory</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// A path is valid iff:</span>
    <span class="doccomment">/// - It is not empty</span>
    <span class="doccomment">/// - It is either absolute or relative in form</span>
    <span class="doccomment">/// - It consists of a &quot;/&quot;-separated sequence of *names*</span>
    <span class="doccomment">/// - It does not end in a &quot;/&quot; (the only exception being the path &quot;/&quot; itself)</span>
    <span class="doccomment">/// - Each one of these names is a *valid* directory entry name (see the [`DirectorySupport`](../fs/trait.DirectorySupport.html) trait)</span>
    <span class="doccomment">/// - Instead of an alphanumeric name, the special entries &quot;.&quot; and &quot;..&quot; can also appear anywhere in the file path. Their meaning is then similar to their meaning they have at the start of a relative path; &quot;.&quot; specifies staying in the current directory, whereas &quot;..&quot; specifies moving up to the parent directory.</span>
    <span class="kw">fn</span> <span class="ident">valid_path</span>(<span class="ident">path</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="ident">bool</span>;

    <span class="doccomment">///Return the current working directory as a String path</span>
    <span class="doccomment">///The value you return here should be an absolute path with respect to the root path `/`, and should not contain the special names &quot;.&quot; or &quot;..&quot;</span>
    <span class="kw">fn</span> <span class="ident">get_cwd</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">String</span>;

    <span class="doccomment">///Set the current working directory to the path provided in the given String, if it is a valid path.</span>
    <span class="doccomment">/// Returns none if the provided path was invalid.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If a relative path is provided, then that path is interpreted with respect to the current working directory.</span>
    <span class="doccomment">/// As stated above, you should then **not** go through the file system to determine the new cwd, but rather have &quot;..&quot; cancel out the previous directory name, i.e. if the cwd is `test/child` then providing `../child_new` to this method, will unconditionally result in a new cwd of `test/child_new`, whereas it will not necessarily lead there when we read through the file system in the other methods.</span>
    <span class="kw">fn</span> <span class="ident">set_cwd</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">path</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span>()<span class="op">&gt;</span>;

    <span class="doccomment">///Given a path name (possibly relative to the cwd), look up the inode corresponding to this path (the final inode could be either a file or a directory), and return it.</span>
    <span class="doccomment">///Works as follows:</span>
    <span class="doccomment">///1. Figures out what inode the cwd corresponds to (skip this step if `path` is absolute)</span>
    <span class="doccomment">///2. Reads `path` through the file system</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///Returns an error if</span>
    <span class="doccomment">/// - the path is invalid</span>
    <span class="doccomment">/// - any directory, referenced in the path (or the cwd), does not exist</span>
    <span class="doccomment">/// - any of the intermediate names refers to a file that is not of directory type.</span>
    <span class="kw">fn</span> <span class="ident">resolve_path</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">path</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Inode</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">///Create a new directory at the given path, where the last name of the path is the name for the new directory.</span>
    <span class="doccomment">///For example, the path `/test/dir` will create a directory named `dir` in the parent directory `test`.</span>
    <span class="doccomment">///Returns the newly created inode in case of success. Note that the newly created directory is already referenced once, i.e. its `nlink` field is not 0.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///New directories are created with 2 default entries in them, i.e. &quot;.&quot; and &quot;..&quot; (in this order), that point to the current directory&#39;s inode and its parent&#39;s inode, respectively. This allows us to easily go back to the parent directory of the current directory, and to succinctly reference sibling files and folders in the same directory.</span>
    <span class="doccomment">///Note that the addition of &quot;..&quot; causes the `nlink` field of the parent directory to increase by 1.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///Error</span>
    <span class="doccomment">/// - if the path is not valid</span>
    <span class="doccomment">/// - if the path&#39;s prefix (i.e. the part of the path without the name of the directory that we are about to create) does not exist in the file system yet.</span>
    <span class="doccomment">/// - if the last part of the path is not a valid directory name (i.e. it cannot be &quot;.&quot; or &quot;..&quot;)</span>
    <span class="kw">fn</span> <span class="ident">mkdir</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">path</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Inode</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">///Remove the directory entry located at path `path`, i.e. set the `inum` of this entry to 0 and the name of the entry to all zeroes, i.e. to `&quot;0&quot;.repeat(*DIRNAME_SIZE)`</span>
    <span class="doccomment">///For example, the path `/test/dir` will (on success) delete the directory entry &quot;dir&quot; in the parent directory `test`.</span>
    <span class="doccomment">///In essence, the inverse of `mkdir`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///Decreases the `nlink` field of the deleted entry by 1 (unless we just deleted a cyclic reference to the parent), and frees the inode in case `nlink` decreases to 0. In the latter case, a reference to the inode also gets deleted (since &quot;..&quot; in the entry&#39;s inode disappears when it is freed)</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///Errors and does nothing else in the following cases:</span>
    <span class="doccomment">///- the path ends in &quot;.&quot; or &quot;..&quot;; these entries cannot be removed</span>
    <span class="doccomment">///- the path is not valid</span>
    <span class="doccomment">///- the path does not exist yet in the file system, which includes the next bullet;</span>
    <span class="doccomment">///- the entry is not present in the directory</span>
    <span class="doccomment">///- the entry we are about to delete is itself a directory and non-empty (apart from the 2 default entries) - note: you cannot judge emptiness just from the size of the file, as it might contain directory entries that were previously unlinked as well</span>
    <span class="kw">fn</span> <span class="ident">unlink</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">path</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;
}

<span class="doccomment">/// Support caching for inodes. Read more about what exactly this entails in assignment [`g_caching_inodes.rs`](../../cplwm_sol/g_caching_inodes/index.html) in the solution folder.</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">InodeCacheSupport</span>: <span class="ident">InodeSupport</span> {
    <span class="doccomment">/// `i_get_mut` is a new version of `i_get` that takes a mutable reference to self.</span>
    <span class="doccomment">///This is required since getting an inode from the disk potentially alters the cache.</span>
    <span class="doccomment">///The original implementation of `i_get` should now only read values from the cache, and not fetch them from disk, so that `self` does not have to be mutable there</span>
    <span class="doccomment">///This function then subsumes the behavior of `iget`, by behaving in the following way;</span>
    <span class="doccomment">///</span>
    <span class="doccomment">///Finds the inode corresponding to `i` and returns it.</span>
    <span class="doccomment">///Looks in the cache first and returns a copy if the inode is present.</span>
    <span class="doccomment">///If the inode is not there, reads it from disk and puts it in the cache.</span>
    <span class="doccomment">///When looking for an entry to replace in the cache, `i_get_mut` will evict the first entry it finds that currently has no other references to it (you can check this using the `strong_count` method of the `Rc` type). *Before evicting the old entry, make sure to persist its contents to the disk.*</span>
    <span class="doccomment">///After eviction, the read `DInode` is wrapped in a `CachedInode`, written into the cache, and a copy of it is returned to the caller.</span>
    <span class="kw">fn</span> <span class="ident">i_get_mut</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">i</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Inode</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">///Is the given inode currently in the inode cache?</span>
    <span class="kw">fn</span> <span class="ident">is_cached</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">inum</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="ident">bool</span>;

    <span class="doccomment">///Alternative version of `mkfs`, that allows us to specify the number of entries in the inode cache.</span>
    <span class="doccomment">///Interpret the original `mfks` function as a more specific variant of this function, where the number of cache entries for inodes is fixed to 5.</span>
    <span class="kw">fn</span> <span class="ident">mkfs_cached</span><span class="op">&lt;</span><span class="ident">P</span>: <span class="ident">AsRef</span><span class="op">&lt;</span><span class="ident">Path</span><span class="op">&gt;&gt;</span>(
        <span class="ident">path</span>: <span class="ident">P</span>,
        <span class="ident">sb</span>: <span class="kw-2">&amp;</span><span class="ident">SuperBlock</span>,
        <span class="ident">nb_cache_entries</span>: <span class="ident">u64</span>,
    ) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;

    <span class="doccomment">///Alternative version of `mountfs`, that allows us to specify the number of entries in the inode cache.</span>
    <span class="doccomment">///Interpret the original `mountfs` function as a more specific variant of this function, where the number of cache entries for inodes is fixed to 5.</span>
    <span class="kw">fn</span> <span class="ident">mountfs_cached</span>(<span class="ident">dev</span>: <span class="ident">Device</span>, <span class="ident">nb_cache_entries</span>: <span class="ident">u64</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span>;
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "cplfs_api";</script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script></body></html>