initSidebarItems({"constant":[["DIRECT_POINTERS","Hard-coded number of data blocks each inode can point to"],["DIRNAME_SIZE","Hard-coded number of characters each directory entry can contain for its name"],["ROOT_INUM","Inode number of the root inode"]],"enum":[["FType","Enum describing file types Currently, either a file `T_FILE`, a directory `T_DIR` or a free inode `T_Free` The file type `T_FREE` is used to signify a free inode, that can be used to allocate a new file or directory."]],"struct":[["Block","Block abstraction, representing a block of data read from the disk. Provides basic methods to read and write data and select structures from and to a block. The basic unit read and written by the device controller, that our file system will make use of."],["Buffer","Buffer abstraction, representing some data on the heap. Buffers can have any size, and will be used further on to build file system `Block`s with, but also as output to read and write functions on files Support regular read and write methods, but also (de)serialization of structures implementing the appropriate traits"],["DINODE_SIZE","Size of an inode in your system, in bytes. This size can only be found out at runtime, which is the reason why we have to wrap this code in a `lazy_static` macro. Notice the use of the `ref` keyword; `DINODE_SIZE` is a reference to an `u64` number, that will only be filled in at runtime. Used to determine the number of inodes per block, which is important for filesystem initialization."],["DIRENTRY_SIZE","Size of an directory entry in your system, in bytes. For similar reasons, again wrapped in the `lazy_static!` macro."],["DInode","Struct describing data held by an inode on the disk. Derives the Serialize and Deserialize traits, to allow for easy (de-)serialization when writing to disk blocks"],["DirEntry","Specific type of inode contents for directories A directory is a file containing a sequence of DirEntry structures, with the `FType` set to the directory type `TDir`."],["Inode","Wrapper around disk inodes `DInode` used for in-memory inodes. Additionally contains the number of the inode `inum`. This information is not required as long as the inode is stored on disk, as it is implicit from the block in which the inode is stored. This is analogous to a `Block` explicitly keeping track of its block number"],["SUPERBLOCK_SIZE","Size the superblock takes up in memory on your system, in bytes. This size can only be found out at runtime, which is the reason why we have to wrap this code in a `lazy_static` macro. Notice the use of the `ref` keyword; `SUPERBLOCK_SIZE` is a reference to an `u64` number, that will only be filled in at runtime. Used to determine the number of inodes per block, which is important for filesystem initialization."],["SuperBlock","Structure representing all file system metadata that we are interested in, and hence the file system's structure. Note that the size of the Superblock struct does not necessarily have to be a full block, as it can just be read from disk contiguously. Rather, the size of `SuperBlock` must be at most as large as a single disk block. Derives `Serialize` and `Deserialize` so we can easily write this block to the disk and read it again after."]],"trait":[["InodeLike","Trait for inode-like behavior, so that we can have different inodes later on, without having to change the interfaces of the inode trait Solely used in testing, so does not require setter methods"]]});