<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `types` mod in crate `cplfs_api`."><meta name="keywords" content="rust, rustlang, rust-lang, types"><title>cplfs_api::types - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../cplfs_api/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class='location'>Module types</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'><a href='../index.html'>cplfs_api</a></p><script>window.sidebarCurrent = {name: 'types', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/cplfs_api/types.rs.html#1-488' title='goto source code'>[src]</a></span><span class='in-band'>Module <a href='../index.html'>cplfs_api</a>::<wbr><a class="mod" href=''>types</a></span></h1><div class='docblock'><p>Module containing the types used in this project.
You can define your own wrappers around these types if you need more than the provided functionality.</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Block.html" title='cplfs_api::types::Block struct'>Block</a></td><td class='docblock-short'><p>Block abstraction, representing a block of data read from the disk.
Provides basic methods to read and write data and select structures from and to a block.
The basic unit read and written by the device controller, that our file system will make use of.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Buffer.html" title='cplfs_api::types::Buffer struct'>Buffer</a></td><td class='docblock-short'><p>Buffer abstraction, representing some data on the heap.
Buffers can have any size, and will be used further on to build file system <code>Block</code>s with, but also as output to read and write functions on files
Support regular read and write methods, but also (de)serialization of structures implementing the appropriate traits</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.DINODE_SIZE.html" title='cplfs_api::types::DINODE_SIZE struct'>DINODE_SIZE</a></td><td class='docblock-short'><p>Size of an inode in your system, in bytes.
This size can only be found out at runtime, which is the reason why we have to wrap this code in a <code>lazy_static</code> macro.
Notice the use of the <code>ref</code> keyword; <code>DINODE_SIZE</code> is a reference to an <code>u64</code> number, that will only be filled in at runtime.
Used to determine the number of inodes per block, which is important for filesystem initialization.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.DIRENTRY_SIZE.html" title='cplfs_api::types::DIRENTRY_SIZE struct'>DIRENTRY_SIZE</a></td><td class='docblock-short'><p>Size of an directory entry in your system, in bytes.
For similar reasons, again wrapped in the <code>lazy_static!</code> macro.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.DInode.html" title='cplfs_api::types::DInode struct'>DInode</a></td><td class='docblock-short'><p>Struct describing data held by an inode on the disk.
Derives the Serialize and Deserialize traits, to allow for easy (de-)serialization when writing to disk blocks</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.DirEntry.html" title='cplfs_api::types::DirEntry struct'>DirEntry</a></td><td class='docblock-short'><p>Specific type of inode contents for directories
A directory is a file containing a sequence of DirEntry structures, with the <code>FType</code> set to the directory type <code>TDir</code>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Inode.html" title='cplfs_api::types::Inode struct'>Inode</a></td><td class='docblock-short'><p>Wrapper around disk inodes <code>DInode</code> used for in-memory inodes.
Additionally contains the number of the inode <code>inum</code>.
This information is not required as long as the inode is stored on disk, as it is implicit from the block in which the inode is stored.
This is analogous to a <a href="../block/struct.Block.html"><code>Block</code></a> explicitly keeping track of its block number</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.SUPERBLOCK_SIZE.html" title='cplfs_api::types::SUPERBLOCK_SIZE struct'>SUPERBLOCK_SIZE</a></td><td class='docblock-short'><p>Size the superblock takes up in memory on your system, in bytes.
This size can only be found out at runtime, which is the reason why we have to wrap this code in a <code>lazy_static</code> macro.
Notice the use of the <code>ref</code> keyword; <code>SUPERBLOCK_SIZE</code> is a reference to an <code>u64</code> number, that will only be filled in at runtime.
Used to determine the number of inodes per block, which is important for filesystem initialization.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.SuperBlock.html" title='cplfs_api::types::SuperBlock struct'>SuperBlock</a></td><td class='docblock-short'><p>Structure representing all file system metadata that we are interested in, and hence the file system's structure.
Note that the size of the Superblock struct does not necessarily have to be a full block, as it can just be read from disk contiguously.
Rather, the size of <code>SuperBlock</code> must be at most as large as a single disk block.
Derives <code>Serialize</code> and <code>Deserialize</code> so we can easily write this block to the disk and read it again after.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.FType.html" title='cplfs_api::types::FType enum'>FType</a></td><td class='docblock-short'><p>Enum describing file types
Currently, either a file <code>T_FILE</code>, a directory <code>T_DIR</code> or a free inode <code>T_Free</code>
The file type <code>T_FREE</code> is used to signify a free inode, that can be used to allocate a new file or directory.</p>
</td></tr></table><h2 id='constants' class='section-header'><a href="#constants">Constants</a></h2>
<table><tr class='module-item'><td><a class="constant" href="constant.DIRECT_POINTERS.html" title='cplfs_api::types::DIRECT_POINTERS constant'>DIRECT_POINTERS</a></td><td class='docblock-short'><p>Hard-coded number of data blocks each inode can point to</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.DIRNAME_SIZE.html" title='cplfs_api::types::DIRNAME_SIZE constant'>DIRNAME_SIZE</a></td><td class='docblock-short'><p>Hard-coded number of characters each directory entry can contain for its name</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.ROOT_INUM.html" title='cplfs_api::types::ROOT_INUM constant'>ROOT_INUM</a></td><td class='docblock-short'><p>Inode number of the root inode</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.InodeLike.html" title='cplfs_api::types::InodeLike trait'>InodeLike</a></td><td class='docblock-short'><p>Trait for inode-like behavior, so that we can have different inodes later on, without having to change the interfaces of the inode trait
Solely used in testing, so does not require setter methods</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "cplfs_api";</script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>