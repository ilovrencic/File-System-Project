initSidebarItems({"trait":[["BlockSupport","This trait adds block-level operations to your file system Do not forget to make sure that `mkfs` now correctly initializes all inodes, as described above."],["DirectorySupport","This trait adds the abstraction of directories and their entries to the file system  Additionally, it supports some convenience methods that allow you to use directory entries with string names (the reason these methods are defined here and not in a trait, is to avoid forcing you to wrap the `DirEntry` type in another type of your own). Do not forget to make sure that `mkfs` now defines a valid (currently empty) root directory."],["FileSysSupport","General trait that each filesystem should implement, that allows us to set up, tear down and load file systems in the tests Additionally, this trait also defines the error type that is used in all of the other traits (which will require implementing this trait) Be warned that the implementation of this trait cannot be kept the same throughout the assignment! Depending on the abstractions your current file system is aware of, it might impose more strict conditions when loading a file system, and might perform extra steps when defining one. For example, when implementing the block layer for your file system, it should not create a root inode as part of `mkfs`, and neither should it check for one when mounting an existing file system. These steps should only be implemented at higher levels of abstraction. In other words, you should not have one blanket implementation of this trait for your entire project, and it will be beneficial to you when e.g. defining the inode abstraction, to take your solution from the block layer, including its implementation of this trait, and create a wrapper around it that (re)implements this and any other relevant traits, so that you can delegate calls to this trait to the wrapped object, and define extra steps on top of them."],["InodeCacheSupport","Support caching for inodes. Read more about what exactly this entails in assignment `g_caching_inodes.rs` in the solution folder."],["InodeRWSupport","This trait additionally provides support to read and write from inodes using buffers; the data structure that we used before to hold the contents of a `Block`. The reason we use `Buffer`s objects and not simply the raw data, is because `Buffer`s also support some methods relating to (de)serialization, which might come in handy in some situations.  We ignore arithmetic over- and underflow in the following functions, for reasons of simplicity."],["InodeSupport","This trait adds the abstraction of inodes to your file system. Do not forget that `mkfs` should now result in a filesystem where each inode is marked as free. Note that this trait does not yet support ways of growing inodes. Growing inodes will become possible when you implement the read and write calls on them in one of the optional assignments."],["PathSupport","Enhance the previous directory support with a notion of file paths (both absolute and relative), enabling the following: - Allows looking up inodes along file paths, to allow for easier navigation. - Allows creating and unlinking (i.e. removing) directories at a given path location. The previously implemented `i_alloc` and `i_free` suffice for regular files, but can result in inconsistencies for directories. - Keeps track of the current working directory in your file system (pick an appropriate type to do this! **WARNING: give this some thought **). Usually, each process has its own current working directory, but since we only model a single process, we just store the current working directory in the file system."]]});