<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `FileSysSupport` trait in crate `cplfs_api`."><meta name="keywords" content="rust, rustlang, rust-lang, FileSysSupport"><title>cplfs_api::fs::FileSysSupport - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../cplfs_api/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class='location'>Trait FileSysSupport</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#associated-types">Associated Types</a><div class="sidebar-links"><a href="#associatedtype.Error">Error</a></div><a class="sidebar-title" href="#required-methods">Required Methods</a><div class="sidebar-links"><a href="#tymethod.mkfs">mkfs</a><a href="#tymethod.mountfs">mountfs</a><a href="#tymethod.sb_valid">sb_valid</a><a href="#tymethod.unmountfs">unmountfs</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class='location'><a href='../index.html'>cplfs_api</a>::<wbr><a href='index.html'>fs</a></p><script>window.sidebarCurrent = {name: 'FileSysSupport', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/cplfs_api/fs.rs.html#23-91' title='goto source code'>[src]</a></span><span class='in-band'>Trait <a href='../index.html'>cplfs_api</a>::<wbr><a href='index.html'>fs</a>::<wbr><a class="trait" href=''>FileSysSupport</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust trait'>pub trait FileSysSupport: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> {
    type <a href='#associatedtype.Error' class="type">Error</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/std/error/trait.Error.html" title="trait std::error::Error">Error</a>;
    fn <a href='#tymethod.sb_valid' class='fnname'>sb_valid</a>(sb: &amp;<a class="struct" href="../../cplfs_api/types/struct.SuperBlock.html" title="struct cplfs_api::types::SuperBlock">SuperBlock</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>;
<div class='item-spacer'></div>    fn <a href='#tymethod.mkfs' class='fnname'>mkfs</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb: &amp;<a class="struct" href="../../cplfs_api/types/struct.SuperBlock.html" title="struct cplfs_api::types::SuperBlock">SuperBlock</a><br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="../../cplfs_api/fs/trait.FileSysSupport.html#associatedtype.Error" title="type cplfs_api::fs::FileSysSupport::Error">Error</a>&gt;;
<div class='item-spacer'></div>    fn <a href='#tymethod.mountfs' class='fnname'>mountfs</a>(dev: <a class="struct" href="../../cplfs_api/controller/struct.Device.html" title="struct cplfs_api::controller::Device">Device</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="../../cplfs_api/fs/trait.FileSysSupport.html#associatedtype.Error" title="type cplfs_api::fs::FileSysSupport::Error">Error</a>&gt;;
<div class='item-spacer'></div>    fn <a href='#tymethod.unmountfs' class='fnname'>unmountfs</a>(self) -&gt; <a class="struct" href="../../cplfs_api/controller/struct.Device.html" title="struct cplfs_api::controller::Device">Device</a>;
}</pre></div><div class='docblock'><p>General trait that each filesystem should implement, that allows us to set up, tear down and load file systems in the tests
Additionally, this trait also defines the error type that is used in all of the other traits (which will require implementing this trait)
Be warned that the implementation of this trait cannot be kept the same throughout the assignment!
Depending on the abstractions your current file system is aware of, it might impose more strict conditions when loading a file system, and might perform extra steps when defining one.
For example, when implementing the block layer for your file system, it should not create a root inode as part of <code>mkfs</code>, and neither should it check for one when mounting an existing file system. These steps should only be implemented at higher levels of abstraction.
In other words, you should <em>not</em> have one blanket implementation of this trait for your entire project, and it will be beneficial to you when e.g. defining the inode abstraction, to take your solution from the block layer, including its implementation of this trait, and create a wrapper around it that (re)implements this and any other relevant traits, so that you can delegate calls to this trait to the wrapped object, and define extra steps on top of them.</p>
<p>Consult the documentation of <a href="../types/struct.SuperBlock.html"><code>SuperBlock</code></a> for more detailed information on the proper layout of the file system and the meaning of the different superblock components</p>
<p><em>HINT</em>: consider caching your filesystem superblock when creating or loading a file system, so you do not have to read it each time you need it</p>
</div>
            <h2 id='associated-types' class='small-section-header'>Associated Types<a href='#associated-types' class='anchor'></a></h2><div class='methods'><h3 id='associatedtype.Error' class='method'><code>type <a href='#associatedtype.Error' class="type">Error</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/std/error/trait.Error.html" title="trait std::error::Error">Error</a></code></h3><div class='docblock'><p>The type of the errors of your implementation.
Read more about how to define your own errors in the documentation of <a href="../error_given/index.html"><code>error_given</code></a>.</p>
<p>Note the “supertrait” your error type must implement:
<a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>error::Error</code></a>
This is the base trait for all Rust errors, click
on it to see the methods you must implement.</p>
<p>Note that you can use the same error type for multiple parts of the assignment.</p>
</div></div><span class='loading-content'>Loading content...</span>
            <h2 id='required-methods' class='small-section-header'>Required methods<a href='#required-methods' class='anchor'></a></h2><div class='methods'><h3 id='tymethod.sb_valid' class='method'><code>fn <a href='#tymethod.sb_valid' class='fnname'>sb_valid</a>(sb: &amp;<a class="struct" href="../../cplfs_api/types/struct.SuperBlock.html" title="struct cplfs_api::types::SuperBlock">SuperBlock</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></h3><div class='docblock'><p>Static method to check if a given superblock represents a valid file system.
You will need this both when creating a new file system, and loading an existing one from disk</p>
<p>More concretely, the following conditions need to hold to make a <code>SuperBlock</code> a possibly valid representation of a file system</p>
<ul>
<li>the regions have to appear in the right order</li>
<li>the regions have to be sufficiently large to hold <code>ninodes</code> inodes (calculated using the size of your inodes) and to hold and keep track of <code>ndatablocks</code> datablocks</li>
<li>the regions have to physically fit on the disk together, i.e. fall within the first <code>nblocks</code> blocks</li>
</ul>
</div><h3 id='tymethod.mkfs' class='method'><code>fn <a href='#tymethod.mkfs' class='fnname'>mkfs</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(path: P, sb: &amp;<a class="struct" href="../../cplfs_api/types/struct.SuperBlock.html" title="struct cplfs_api::types::SuperBlock">SuperBlock</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="../../cplfs_api/fs/trait.FileSysSupport.html#associatedtype.Error" title="type cplfs_api::fs::FileSysSupport::Error">Error</a>&gt;</code></h3><div class='docblock'><p>Method to create and mount a new file system from scratch, given a super block (which is a bit more convenient to work with than a bunch of parameters) and a path.
What exactly this method does, depends on the level of abstraction you are implementing.</p>
<p>This method always does the following, regardless of the layer of abstraction:</p>
<ul>
<li>Check if the given superblock is a valid file system superblock</li>
<li>Create a new <code>Device</code> at the given path, to allow the file system to communicate with it</li>
</ul>
<p>Then, subdivide the freshly created device image into the previously described regions:</p>
<ol>
<li>A super block containing the file system metadata at block index 0</li>
<li><em>This is only relevant for the inode layer and up, i.e. ignore this set-up step in the disk block layer.</em>
A list of blocks containing inodes, where all inodes as marked as &quot;free&quot; (since they are free, the rest of their contents is irrelevant and hence unspecified).<br />
<em>You only need to do the following once you support directories:</em>
The first inode (with number 1) describes the &quot;root path&quot;, i.e. the path &quot;/&quot; on UNIX systems. It is initially empty, i.e. has no directory entries inside it.
The root node has its <code>nlink</code> field set to 1 from the start, even though there are no references to it, so that it cannot be deallocated.
Note that inodes start counting at one, and <em>NOT</em> at zero, to avoid confusion with the error return value 0 in the kernel.
However, to avoid off-by-1 errors, room for inode 0 is still allocated in the first inode block on disk (i.e. inode 1 is <em>not</em> stored at address 0 of this block).
This space will under normal circumstances never be used.</li>
<li>A bitmap keeping track of the occupied memory blocks.
This bitmap should initially mark all blocks as &quot;free&quot;, as no block allocations have happened.</li>
<li>A data region to contain the memory blocks themselves
Since all blocks are marked as free after initialization and allocating a block should set its contents to 0, the contents of this region is unimportant.
This data region is assumed to run until the end of the file system.</li>
</ol>
<p>Think about whether the initial <code>Device</code> you create inside this method, which will contain 0 at each address (see the <a href="../controller/struct.Device.html#method.new">documentation</a>), is a valid disk representation, or if it requires extra initialization for one or more of the above regions.
(<em>Hint for the inode layer and up</em>: watch out for the inodes; an all-0 inode will not necessarily come out well during deserialization, and probably needs to be overwritten by an actually free inode)</p>
<p>Make sure your underlying device is in a consistent state and matches the above enumeration at the end of this function.</p>
<p><em>IMPORTANT NOTE</em>: In case you need to loop over inodes here or anywhere else in this project, do so <strong>efficiently</strong>, i.e. if you need to read/write multiple inodes in the same block, only load and store this block once!</p>
<p><em>EXTRA</em>: mkfs is inspired by the unix command of the same name (although this version also immediately mounts the file system)</p>
</div><h3 id='tymethod.mountfs' class='method'><code>fn <a href='#tymethod.mountfs' class='fnname'>mountfs</a>(dev: <a class="struct" href="../../cplfs_api/controller/struct.Device.html" title="struct cplfs_api::controller::Device">Device</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="../../cplfs_api/fs/trait.FileSysSupport.html#associatedtype.Error" title="type cplfs_api::fs::FileSysSupport::Error">Error</a>&gt;</code></h3><div class='docblock'><p>Given an existing <code>Device</code> called <code>dev</code>, make sure that its image corresponds to a valid file system by reading its superblock and checking the following conditions:</p>
<ul>
<li>The superblock is a valid superblock</li>
<li>The block size and number of blocks of the device and superblock agree</li>
</ul>
<p>If these conditions are satisfied, wrap the given <code>Device</code> in a file system and return it.</p>
<p>You do <strong>not</strong> need to deserialize each individual object in each region to check that it is indeed a valid object; to keep matters simple, we will assume that the contents of each region has been properly initialized.
Additionally, we could add <code>dev</code> to the return type to reclaim ownership in case of an error, but we do not bother recovering invalid devices, for simplicity reasons.</p>
</div><h3 id='tymethod.unmountfs' class='method'><code>fn <a href='#tymethod.unmountfs' class='fnname'>unmountfs</a>(self) -&gt; <a class="struct" href="../../cplfs_api/controller/struct.Device.html" title="struct cplfs_api::controller::Device">Device</a></code></h3><div class='docblock'><p>Unmount the give file system, thereby consuming it
Returns the image of the file system, i.e. the <code>Device</code> backing it.
The implementation of this method should be almost trivial</p>
</div></div><span class='loading-content'>Loading content...</span>
            <h2 id='implementors' class='small-section-header'>Implementors<a href='#implementors' class='anchor'></a></h2><div class='item-list' id='implementors-list'></div><span class='loading-content'>Loading content...</span><script type="text/javascript" src="../../implementors/cplfs_api/fs/trait.FileSysSupport.js" async></script></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "cplfs_api";</script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>